Document( 
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(ex <http://example.com/>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)

    Group (
      (* triplestordf:combine-rdf-lists *) Group 100 (
        Forall ?base ?prop (
          If And(
            ?base[?prop -> rdf:nil]
            ) Then Do (
              Retract(?base[?prop -> rdf:nil])
              Assert(?base[?prop -> List()])
              ) 
          )

        Forall ?base ?list(
          If And(
            ?base[triplestordf:as-list -> ?list]
            Not (Exists ?s ?p (?s[?p -> ?base]))
            ) Then Do (
              Retract(?base[triplestordf:as-list -> ?list])
              ) 
          )

        Forall ?base ?first ?rest(
          If And(
            ?base[rdf:rest -> ?rest]
            ?base[rdf:first -> ?first]
            External(pred:is-list(?rest))
            ) Then Do (
              Retract(?base[rdf:rest -> ?rest])
              Retract(?base[rdf:first -> ?first])
              Assert(?base[triplestordf:as-list -> External(func:insert-before(?rest 0 ?first))])
              ) 
          )

        Forall ?subject ?prop ?listbase ?aslist (
            If And(
              ?subject[?prop -> ?listbase]
              ?listbase[triplestordf:as-list -> ?aslist]
              ) Then Do (
                Retract(?subject[?prop -> ?listbase])
                Assert(?subject[?prop -> ?aslist])
                ) 
            )
        )

        (* ex:combine-target-lists *) Group 50 (
            (* ex:combine-target-lists-iter *) Forall ?target ?targetprop ?sourcelist ?sourceprop ?sourcepart ?tmplist (
              If And(
                ex:combine-target-lists-state(?target ?targetprop ?sourcelist ?sourceprop ?currentlistpart)
                ?sourcepart[?sourceprop -> ?newlistpart]
                ?sourcepart = External( func:get(?sourcelist 0))
                ) Then Do (
                  Assert( ex:combine-target-lists-state(?target ?targetprop External(func:remove (?sourcelist 0)) ?sourceprop External(func:concatenate(?currentlistpart ?newlistpart))) )
                  )
              )
            (* ex:combine-target-lists-finalize *) Forall ?target ?targetprop ?sourcelist ?sourceprop ?sourcepart ?tmplist (
              If And(
                ex:combine-target-lists-state(?target ?targetprop ?sourcelist ?sourceprop ?currentlistpart)
                0 = External(func:count(?sourcelist))
                ) Then Do (
                  Assert( ?target[?targetprop -> ?currentlistpart])
                  )
              )
            )

        (* ex:init-defrules *) Group 10 (
            (* ex:init-defrule-per-forall *) Forall ?rule ?formula(
              If And(
                ?rule[rdf:type -> rif:Forall]
                ?rule[rif:formula -> ?formula]
                ) Then Do ((?defrule New()) (?actionlist New())
                  Assert( ?defrule[rdf:type -> cs:Defrule] )
                  Assert( ?defrule[ex:uses-patterns-as-conditional -> ?rule] )
                  Assert( ?defrule[ex:out-as-conditional -> List()] )
                  Assert( ?defrule[ex:uses-action-from -> ?formula])
                  Assert( ?defrule[ex:bound-variables -> List()] )
                  )
              )
            (* ex:add-action-to-defrule *) Forall ?rule ?formula ?actionlist(
              If And(
                ?rule[ex:uses-action-from -> ?formula]
                ?formula[ex:as-action -> ?actionlist]
                ) Then Do (
                  Assert(?rule[cs:action -> ?actionlist])
                  )
              )
            (* ex:add-conditional-to-defrule *) Forall ?clipsrule ?rifrule ?conditionlist(
                If And(
                  ?clipsrule[ex:uses-as-conditional -> ?rifrule]
                  ?rifrule[ex:as-conditional -> ?conditionlist]
                  ) Then Do (
                    Assert(?clipsrule[cs:conditional-element -> ?conditionlist])
                    )
                )


            (* ex:combine-formulas-to-pattern *) Group (
                Group 20 (
                  (* ex:init-pattern-to-add *) Forall ?defrule ?clipsrule ?pattern (
                    If And (
                      ?defrule[ex:uses-patterns-as-conditional -> ?rifrule]
                      ?rifrule[rif:pattern -> ?pattern]
                      ) Then Do (
                        Assert( ?defrule[ex:add-pattern-as-conditional -> ?pattern] )
                        )
                    )

                  (* ex:add-formula-as-pattern-to-list *) Forall ?rule ?pattern ?defrule ?defruleconditionlist (
                    If And (
                      ?defrule[ex:uses-patterns-as-conditional -> ?rifrule]
                      ?defrule[ex:add-pattern-as-conditional -> ?pattern]

                      ?pattern[ex:as-conditional -> ?patternconditions]
                      ?pattern[ex:unbound-variables -> ?neededboundvars]
                      ?pattern[ex:binds-variables -> ?newsuppliedboundvars]
                      ?defrule[ex:bound-variables -> ?suppliedboundvars]
                      List() = External( func:except(?neededboundvars ?suppliedboundvars) )
                      ) Then Do (
                        (?currentconditions ?defrule[ex:out-as-conditional -> ?currentconditions])
                        Retract( ?defrule[ex:add-pattern-as-conditional -> ?pattern] )
                        Assert( ?defrule[ex:implemented-pattern -> ?pattern] )
                        Modify( ?defrule[ex:out-as-conditional -> External(func:concatenate(?currentconditions ?patternconditions))])
                        Modify( ?defrule[ex:bound-variables -> External(func:union(?suppliedboundvars ?suppliedboundvars))] )
                        )
                    )
                  ) Group 3 (
                    (* ex:complete-pattern-to-conditional *) Forall ?defrule ?clipsrule ?conditional (
                      If And (
                        ?defrule[ex:uses-patterns-as-conditional -> ?rifrule]
                        Not( Exists ?pattern (?defrule[ex:add-pattern-as-conditional -> ?pattern]) )
                        ?defrule[ex:out-as-conditional -> ?conditional]
                        ) Then Do (
                          Assert(?defrule[cs:conditional-element -> ?conditional])
                          Retract(?defrule[ex:out-as-conditional -> ?conditional])
                          Assert( ?defrule[ex:brubru2 -> ex:brubru])
                          )
                      )
                    )
                  )
                  (* ex:action-block-to-clips-action *) Forall ?actionblock ?actions (
                      If And(
                        ?actionblock[rif:actions -> ?actions]
                      ) Then Do (
                        Assert( ex:combine-target-lists-state(?actionblock ex:as-clips-action ?actions ex:as-clips-action List()) )
                      )
                    )

                  (* ex:transform-do *) Group (
                    (* ex:init-transform-do *) Forall ?rifnode ?actionlist (
                      If And(
                        ?rifnode[rif:actions -> ?actionlist]
                        External(pred:is-list(?actionlist))
                        ) Then Do (
                          Assert( ?rifnode[ex:in-transform-do -> ?actionlist] )
                          Assert( ?rifnode[ex:out-transform-do -> External(func:make-list())] )
                        )
                    )

                      (* ex:end-transform-do *) Forall ?rifnode ?in ?out (
                        If And (
                          ?rifnode[ex:in-transform-do -> ?in]
                          0 = External(func:count(?in))
                          ?rifnode[ex:out-transform-do -> ?out]
                          ) Then Do (
                            Assert(?rifnode[ex:as-action -> ?out])
                            Retract( ?rifnode[ex:in-transform-do -> ?in] )
                            Retract( ?rifnode[ex:out-transform-do -> ?out] )
                            )
                        )

                      (* ex:iter-transform-do *) Forall ?rifnode ?in ?out ?nextactions (
                          If And (
                            ?rifnode[ex:in-transform-do -> ?in]
                            ?rifnode[ex:out-transform-do -> ?out]
                            ?firstaction[ex:as-action -> ?nextactions]
                            External( pred:numeric-not-equal(0 External(func:count(?in))) )
                            ?firstaction = External(func:get(?in 0))
                            ) Then Do (
                              Modify( ?rifnode[ex:in-transform-do -> External(func:remove(?in 0))] )
                              Modify( ?rifnode[ex:out-transform-do -> External(func:concatenate(?out ?nextactions))] )
                              )
                          )

                      )


                      (* ex:transform-assert *) Forall ?rifassert (
                          If And(
                            ?rifassert[rif:target -> ?riftarget]
                            ?riftarget[ex:as-rhspattern -> ?clipsfact]
                            ) Then Do (
                              (?clipsaction New())
                              Assert( ?rifassert[ex:as-action -> External(func:make-list(?clipsaction))] )
                              Assert( ?clipsaction[cs:assert -> ?clipsfact] )
                              )
                          )

                      (* ex:transform-rif-frame *) Group (
                          (* ex:as-expression-transform-rif-frame *) Forall ?rifnode ?slotlist ?slot ?currentconditionalelement ?clipsrestraint ?slotvalue ?slotkey ?constraintsubject(
                            If And (
                              ?rifnode[rdf:type -> rif:Frame]
                              ?rifnode[rif:object -> ?object]
                              ?rifnode[rif:slots -> ?slotlist]
                              ?object[ex:as-expression -> ?expressionsubject]
                              ?slot[rif:slotkey -> ?slotkey]
                              ?slotkey[ex:as-expression -> ?expressionpredicate]
                              ?slot[rif:slotvalue -> ?slotvalue]
                              ?slotvalue[ex:as-expression -> ?expressionobject]
                              External(pred:is-list(?slotlist))
                              1 = External(func:count(?slotlist))
                              External(pred:list-contains(?slotlist ?slot))
                              ) Then Do (
                                (?clipsnode New())
                                (?slotsubject New())
                                (?slotpredicate New())
                                (?slotobject New())
                                Assert( ?rifnode[ex:as-rhspattern -> ?clipsnode] )
                                Assert( ?clipsnode[cs:deftemplate-name -> "TripleTemplate"] )
                                Assert( ?clipsnode[cs:slot -> External(func:make-list(?slotsubject ?slotpredicate ?slotobject))] )
                                Assert( ?slotsubject[cs:slot-name -> "subject"] )
                                Assert( ?slotsubject[cs:field -> External(func:make-list(?expressionsubject))])
                                Assert( ?slotpredicate[cs:slot-name -> "predicate"] )
                                Assert( ?slotpredicate[cs:field -> External(func:make-list(?expressionpredicate))])
                                Assert( ?slotobject[cs:slot-name -> "object"] )
                                Assert( ?slotobject[cs:field -> External(func:make-list(?expressionobject))])
                                )
  )

  (* ex:add-slot-transform-rif-frame *) Forall ?rifnode ?slotlist ?slot ?currentconditionalelement ?clipsrestraint ?slotvalue ?slotkey ?constraintsubject(
      If And (
        ?rifnode[rdf:type -> rif:Frame]
        ?rifnode[rif:object -> ?object]
        ?object[ex:as-constraint -> ?constraintsubject]
        ?rifnode[rif:slots -> ?slotlist]
        ?slot[rif:slotkey -> ?slotkey]
        ?slotkey[ex:as-constraint -> ?constraintpredicate]
        ?slot[rif:slotvalue -> ?slotvalue]
        ?slotvalue[ex:as-constraint -> ?constraintobject]
        External(pred:is-list(?slotlist))
        1 = External(func:count(?slotlist))
        External(pred:list-contains(?slotlist ?slot))
        ?constraintsubject[ex:as-constraint-needs-additional-conditionals -> ?additionalconditionalssubject]
        ?constraintpredicate[ex:as-constraint-needs-additional-conditionals -> ?additionalconditionalspredicate]
        ?constraintobject[ex:as-constraint-needs-additional-conditionals -> ?additionalconditionalsobject]
        ) Then Do (
          (?clipsconditionalelement New())
          (?slotsubject New())
          (?slotpredicate New())
          (?slotobject New())

          Assert( ?rifnode[
            ex:as-conditional
            ->
            External(func:concatenate(
                ?additionalconditionalssubject
                ?additionalconditionalspredicate
                ?additionalconditionalsobject
                External(func:make-list(?clipsconditionalelement))
                ))
          ])
          Assert( ?rifnode[ex:binds-variables -> List()] )
          Assert( ?rifnode[ex:unbound-variables -> List()] )
          Assert( ?clipsconditionalelement[rdf:type -> cs:TemplatePatternCE])
          Assert( ?clipsconditionalelement[cs:deftemplate-name -> "TripleTemplate"] )
          Assert( ?clipsconditionalelement[cs:slot -> External(func:make-list(?slotsubject ?slotpredicate ?slotobject))] )
          Assert( ?slotsubject[cs:slot-name -> "subject"] )
          Assert( ?slotsubject[cs:constraint -> ?constraintsubject])
          Assert( ?slotpredicate[cs:slot-name -> "predicate"] )
          Assert( ?slotpredicate[cs:constraint -> ?constraintpredicate])
          Assert( ?slotobject[cs:slot-name -> "object"] )
          Assert( ?slotobject[cs:constraint -> ?constraintobject])
  )
  )
  )

  (* ex:transform-rif-variable *) Forall ?rifnode ?varname (
      If And (
        ?rifnode[rif:varname -> ?varname]
        ) Then Do ((?clipsnode New())
          Assert(?rifnode[ex:as-constraint -> ?clipsnode])
          Assert(?rifnode[ex:as-expression -> ?clipsnode])
          Assert(?clipsnode[cs:variable-name -> ?varname])
          Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
          )
      )

  (* ex:transform-rif-consts *) Group (
      (* ex:value-to-constraint *) Forall ?rifnode ?value (
        If And(
          ?rifnode[rif:value -> ?value]
          ) Then Do ((?clipsnode New())
            Assert(?rifnode[ex:as-constraint -> ?clipsnode])
            Assert(?rifnode[ex:as-expression -> ?clipsnode])
            Assert(?clipsnode[cs:string -> External(crifi:literal-to-clipsconstant(?value))])
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
            )
        )
      (* ex:constIRI-to-constraint *) Forall ?rifnode ?iristring(
        If And(
          ?rifnode[rif:constIRI -> ?iristring]
          ) Then Do ((?clipsnode New())
            Assert( ?rifnode[ex:as-constraint -> ?clipsnode] )
            Assert( ?rifnode[ex:as-expression -> ?clipsnode] )
            Assert( ?clipsnode[cs:symbol -> External( crifi:iri-to-clipsconstant(?iristring))] )
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
            )
        )
      )
      )

      (* ex:normalize-rules *) Group 50 (
          (* ex:move-pattern-outwards *)Forall ?innerrule ?outerrule ?pattern(
            If And(
              ?outerrule[rdf:type -> rif:Forall]
              ?innerrule[rdf:type -> rif:Forall]
              ?outerrule[rif:formula -> ?innerrule]
              ?innerrule[rif:pattern -> ?pattern]
              ) Then Do (
                Retract(?innerrule[rif:pattern -> ?pattern])
                Assert(?outerrule[rif:pattern -> ?pattern])
                )
            )
          (* ex:move-action-outwards *) Forall ?innerrule ?outerrule ?action(
            If And(
              ?outerrule[rdf:type -> rif:Forall]
              ?innerrule[rdf:type -> rif:Forall]
              ?outerrule[rif:formula -> ?innerrule]
              ?innerrule[rif:formula -> ?action]
              Not( Exists ?pattern ( ?innerrule[rif:pattern -> ?pattern]))
              ) Then Do (
                Assert(?outerrule[rif:formula -> ?action])
                Retract(?innerrule)
                )
            )
          (* ex:expand-implies *) Forall ?implies ?outerrule ?pattern ?action(
              If And(
                ?outerrule[rdf:type -> rif:Forall]
                ?outerrule[rif:formula -> ?implies]
                ?implies[rdf:type -> rif:Implies]
                ?implies[rif:if -> ?formula]
                ?implies[rif:then -> ?action]
                ) Then Do (
                  Assert(?outerrule[rif:pattern -> ?formula])
                  Modify(?outerrule[rif:formula -> ?action])
                  Retract(?implies)
                  )
              )
          )
        )
      )
