Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(ex <http://example.com/>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Prefix(modelA <http://white.gobo/modelA#>)
    Prefix(self <http://example.com/constants#>)
    Group(
      Group -100 (
        (* self:rule01 *) Forall ?rifvar ?varname (
          If And (
            ?rifvar[rif:varname -> ?varname]
            Not( Exists ?clipsnode (?rifvar[ex:as-expression -> ?clipsnode]))
            Not( Exists ?clipsnode (?rifvar[ex:provides-expression -> ?clipsnode]))
          ) Then Do (
            Assert( ?rifvar # modelA:missing-var-binding )
            Execute(crifi:set-graph-in-errorstate(External(func:concat("Missing binding for rif:Var with name " ?varname " (modelA:missing-var-binding). Might be missing mention of variable in rif:Forall or rif:Exists."))))
          )
        )
      )
      Group -102 (
        (* self:rule02 *) Forall ?clipsvar (
          If And (
            ?clipsvar # cs:Variable
            Not( Exists ?varname (?clipsvar[cs:variable-name -> ?varname]))
            Not( Exists ?varname (?clipsvar[cs:var-as-const-expr -> ?varname]))
          ) Then Do (
            Assert( ?clipsvar # modelA:missing-var-expression )
            Execute(crifi:set-graph-in-errorstate("A cs:Variable has no expression. missing cs:variable-name or cs:var-as-const-expr.(modelA:missing-var-expression)"))
          )
        )
        (* self:rule03 *) Forall ?rifvar ?varname ?clipsvar (
          If And (
            ?rifvar[rif:varname -> ?varname]
            ?rifvar[ex:provides-expression -> ?clipsvar]
            Not( Exists ?rifvarchild (
              ?rifvarchild[ex:as-expression -> ?clipsvar]
            ))
          ) Then Do (
            Execute(crifi:set-graph-in-errorstate(External(func:concat("Missing use for variable with name " ?varname))))
          )
        )
      )
      Group (
        (* self:rule04 *) Forall ?rifvar ?factvar ?varname (
          If And (
            ?factvar # ex:Variable
            ?rifvar[ex:provides-expression -> ?factvar]
            ?rifvar[rif:varname -> ?varname]
            Not (Exists ?factname ( ?factvar[cs:variable-name -> ?factname] ))
          ) Then Do (
            Assert(?factvar # cs:Variable)
            Assert(?factvar[cs:variable-name -> ?varname])
          )
        )
        (* self:rule05 *) Forall ?factvar ?factindex (
          If And (
            ?factvar # ex:Variable
            Not(Exists ?rifvar (?rifvar[ex:provides-expression -> ?factvar]))
            ex:currentfactindex(?factindex)
            Not (Exists ?factname ( ?factvar[cs:variable-name -> ?factname] ))
          ) Then Do (
            Assert(?factvar # cs:Variable)
            Retract( ex:currentfactindex(?factindex) )

            Assert( ex:currentfactindex(External(func:numeric-add(?factindex 1))))
            Assert( ?factvar[cs:variable-name -> External(func:concat("fcct" ?factindex))] )

          )
        )
        (* self:rule06 *) Forall ?factvar ?rifformula ?factindex (
          If And (
            ?factvar # cs:Variable
            ex:currentfactindex(?factindex)
            Not (Exists ?factname ( ?factvar[cs:variable-name -> ?factname] ))
            Or (
              ?rifformula # rif:Frame
              ?rifformula # rif:Atom
              ?rifformula # rif:Member
              ?rifformula # rif:Subclass
              ?rifformula # rif:Equal
            )
            ?rifformula[ex:as-expression -> ?factvar]
          ) Then Do (
            Retract( ex:currentfactindex(?factindex) )

            Assert( ex:currentfactindex(External(func:numeric-add(?factindex 1))))
            Assert( ?factvar # cs:Variable )
            Assert( ?factvar[cs:variable-name -> External(func:concat("fct" ?factindex))] )

          )
        )
        ex:currentfactindex(1)
      )
      (* ex:rif-inheritance *) Group 100 (
        (* self:rule07 *) Forall ?parent ?child ?x (
          If And (
            Or (
              ?parent[rif:formula -> ?child]
              ?parent[rif:object -> ?child]
              ?parent[rif:if -> ?child]
              ?parent[rif:then -> ?child]
              ?parent[rif:target -> ?child]
              ?parent[rif:op -> ?child]
              ?parent[rif:payload -> ?child]
              ?parent[rif:pattern -> ?child]
              ?parent[rif:left -> ?child]
              ?parent[rif:right -> ?child]
              ?parent[rif:rest -> ?child]
              ?parent[rif:class -> ?child]
              ?parent[rif:instance -> ?child]
              ?parent[rif:sub -> ?child]
              ?parent[rif:super -> ?child]
            )
            Not(?child[rif:constIRI -> ?x])
            Not(?child[rif:value -> ?x])
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?child] )
          )
        )
        (* self:rule09 *) Forall ?parent ?atom ?childlist ?child ?x (
          If And (
            ?parent[rif:content -> ?atom]
            ?atom[rif:args -> ?childlist]
            External(pred:is-list(?childlist))
            Or (
              ?child # rif:Var
              ?child # rif:Const
              ?child # rif:List
              ?child # rif:External
            )
            Not(?child[rif:constIRI -> ?x])
            Not(?child[rif:value -> ?x])
            External(pred:list-contains(?childlist ?child))
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?child] )
          )
        )
        (* self:rule10 *) Forall ?parent ?slotlist ?slot ?childkey ?x (
          If And (
            ?parent[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            ?slot[rif:slotkey -> ?childkey]
            Not(?childkey[rif:constIRI -> ?x])
            Not(?childkey[rif:value -> ?x])
            External(pred:list-contains(?slotlist ?slot))
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?childkey] )
          )
        )
        (* self:rule11 *) Forall ?parent ?slotlist ?slot ?childvalue ?x (
          If And (
            ?parent[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            ?slot[rif:slotvalue -> ?childvalue]
            Not(?childvalue[rif:constIRI -> ?x])
            Not(?childvalue[rif:value -> ?x])
            External(pred:list-contains(?slotlist ?slot))
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?childvalue] )
          )
        )
        (* self:rule12 *) Forall ?parent ?childlist ?child ?x (
          If And (
            Or (
              ?parent[rif:sentences -> ?childlist]
              ?parent[rif:formulas -> ?childlist]
              ?parent[rif:actions -> ?childlist]
              ?parent[rif:args -> ?childlist]
              ?parent[rif:items -> ?childlist]
            )
            External(pred:is-list(?childlist))
            Or (
              ?child # rif:Group
              ?child # rif:Forall
              ?child # rif:Frame
              ?child # rif:Atom
              ?child # rif:Assert
              ?child # rif:Retract
              ?child # rif:Do
              ?child # rif:Modify
              ?child # rif:Subclass
              ?child # rif:Equal
              ?child # rif:Member
              ?child # rif:Var
              ?child # rif:Const
              ?child # rif:List
              ?child # rif:And
              ?child # rif:INeg
              ?child # rif:Or
              ?child # rif:Not
              ?child # rif:Exists
              ?child # rif:External
              ?child # rif:Execute
            )
            Not(?child[rif:constIRI -> ?x])
            Not(?child[rif:value -> ?x])
            External(pred:list-contains(?childlist ?child))
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?child] )
          )
        )
        (* self:rule13 *) Forall ?rifdo ?actionvar ?rifvar ?rifframe (
          If And (
            ?rifdo[rif:actionVar -> ?actionvar]
            External(pred:is-list(?actionvar))
            ?rifvar # rif:Var
            ?rifframe # rif:Frame
            External(pred:list-contains(?actionvar ?rifvar))
            External(pred:list-contains(?actionvar ?rifframe))
          ) Then Do (
            Assert( ?rifvar[ex:inherits-data -> ?rifframe] )
            Assert( ?rifvar[ex:inherits-data -> ?rifdo] )
          )
        )

        (* self:rule14 *) Forall ?parent ?child ?grandchild (
          If And (
            ?parent[ex:inherits-data -> ?child]
            ?child[ex:inherits-data -> ?grandchild]
            Or (
              ?grandchild # rif:Const
              ?grandchild # rif:Var
            )
          ) Then Do (
            Assert( ?parent[ex:inherits-data -> ?grandchild])
          )
        )
      )
      (* ex:transform-terms-asdf *) Group (
        Forall ?rifdo ?actionvar ?rifvar ?varname (
          If And (
            ?rifdo[rif:actionVar -> ?actionvar]
            External(pred:is-list(?actionvar))
            ?rifvar[rif:varname -> ?varname]
            External(pred:list-contains(?actionvar ?rifvar))
          ) Then Do (
            (?clipsnode New())
            Assert(?rifvar[ex:as-constraint -> ?clipsnode])
            Assert(?rifvar[ex:as-expression -> ?clipsnode])
            Assert(?clipsnode[cs:variable-name -> ?varname])
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
            Assert( ?rifvar[ex:inherits-data -> ?rifdo] )
          )
        )
        (* self:rule16 *) Forall ?rifforall ?varlist ?rifvar (
          If And (
            ?rifforall[rif:vars -> ?varlist]
            External(pred:is-list(?varlist))
            ?rifvar # rif:Var
            External(pred:list-contains(?varlist ?rifvar))
          ) Then Do (
            Assert( ?rifvar[ex:inherits-data -> ?rifforall] )
          )
        )
        (* self:rule17 *) Forall ?rifforall ?varlist ?rifvar (
          If And (
            ?rifforall[rif:vars -> ?varlist]
            ?rifforall # rif:Exists
            External(pred:is-list(?varlist))
            ?rifvar # rif:Var
            External(pred:list-contains(?varlist ?rifvar))
          ) Then Do (
            Assert( ?rifvar # ex:brubru5 )
          )
        )
        (* self:rule18 *) Forall ?rifforall ?varlist ?rifvar (
          If And (
            ?rifforall[rif:vars -> ?varlist]
            External(pred:is-list(?varlist))
            ?rifvar # rif:Var
            External(pred:list-contains(?varlist ?rifvar))
          ) Then Do (
            (?clipsnode New())
            Assert(?clipsnode # cs:Variable)
            Assert(?rifvar[ex:provides-expression -> ?clipsnode])
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
          )
        )
        (* self:rule20 *) Forall ?rifvar ?varname ?clipsvar ?clipspattern ?constraintlist (
          If And (
            ?rifvar[rif:varname -> ?varname]
            ?rifvar[ex:provides-expression -> ?clipsvar]
            ?clipspattern[cs:constraints -> ?constraintlist]
            External(pred:list-contains(?constraintlist ?clipsvar))
          ) Then Do (
            Assert(?clipsvar # cs:Variable)
            Assert(?clipsvar[cs:variable-name -> ?varname])
          )
        )
        (* self:rule22 *) Forall ?varchild ?varparent ?varname ?clipsvar(
          If And (
            ?varparent[ex:inherits-data -> ?varchild]
            ?varparent[rif:varname -> ?varname]
            ?varchild[rif:varname -> ?varname]
            ?varparent[ex:provides-expression -> ?clipsvar]
          ) Then Do (
            Assert(?varchild[ex:as-expression -> ?clipsvar])
            Assert(?varchild[ex:as-constraint -> ?clipsvar])
          )
        )
      )

      (* ex:transform-rif-consts *) Group (
        (* ex:value-to-constraint *) Forall ?rifnode ?value (
          If And(
            ?rifnode[rif:value -> ?value]
          ) Then Do ((?clipsnode New())
            Assert(?rifnode[ex:as-constraint -> ?clipsnode])
            Assert(?rifnode[ex:as-expression -> ?clipsnode])
            Assert(?clipsnode[cs:string -> External(crifi:literal-to-clipsconstant(?value))])
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
          )
        )
        (* ex:constIRI-to-constraint *) Forall ?rifnode ?iristring(
          If And(
            ?rifnode[rif:constIRI -> ?iristring]
          ) Then Do ((?clipsnode New())
            Assert( ?rifnode[ex:as-constraint -> ?clipsnode] )
            Assert( ?rifnode[ex:as-expression -> ?clipsnode] )
            Assert( ?clipsnode[cs:symbol -> External( crifi:iri-to-clipsconstant(?iristring))] )
            Assert(?clipsnode[ex:as-constraint-needs-additional-conditionals -> External(func:make-list())])
          )
        )
        (* self:rule26 *) Forall ?riflocal ?name ?rifdocument (
          If And(
            ?rifdocument # rif:Document
            ?rifdocument[ex:inherits-data -> ?riflocal]
            ?riflocal[rif:constname -> ?name]
          ) Then Do (
            (?clipsnode New())
            Assert( ?riflocal[ex:as-constraint -> ?clipsnode] )
            Assert( ?riflocal[ex:as-expression -> ?clipsnode] )
            Assert( ?clipsnode[cs:symbol -> External( crifi:local-to-clipsconstant(?rifdocument ?name))] )
          )
        )
      )
    )
)
