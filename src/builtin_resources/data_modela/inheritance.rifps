Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(ex <http://example.com/>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Prefix(modelA <http://white.gobo/modelA#>)
    Prefix(self <http://example.com/inheritance#>)
    Group 100 (
      (* self:sharedinfo *) Group (
        (* self:rule20 *) Forall ?target ?rifdo ?child ?childlist (
          ?target["rifdoinheritance"^^rif:local -> ?rifdo] :-
          And (
            ?rifdo[rif:actions -> ?childlist]
            ?child["give-inheritance"^^rif:local -> ?target]
            External(pred:list-contains(?childlist ?child))
          )
        )
        (* self:rule21 *) Forall ?target ?rifdo ?child ?actionvar (
          ?target["rifdoinheritance"^^rif:local -> ?rifdo] :-
          And (
            ?rifdo[rif:actionVar -> ?actionvar]
            ?child["give-inheritance"^^rif:local -> ?target]
            ?child = External(func:get(?actionvar 1))
          )
        )
      )
      (* self:init *) Group (
        (* self:rule22 *) Forall ?parent ?slotlist ?child ?slot (
          ?parent["give-inheritance"^^rif:local -> ?child] :- 
          And (
            ?parent[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            Or (
              ?slot[rif:slotkey -> ?child]
              ?slot[rif:slotvalue -> ?child]
            )
            External(pred:list-contains(?slotlist ?slot))
            Or (
              ?child # rif:Var
              Exists ?x (?child[rif:constname -> ?x])
            )
          )
        )
        (* self:rule23 *) Forall ?parent ?arglist ?child (
          ?parent["give-inheritance"^^rif:local -> ?child] :-
          And (
            Or (
              ?parent[rif:items -> ?arglist]
              ?parent[rif:args -> ?arglist]
            )
            External(pred:is-list(?arglist))
            Or (
              ?child # rif:Var
              And (
                ?child # rif:Const
                Exists ?x (?child[rif:constname -> ?x])
              )
            )
            External(pred:list-contains(?arglist ?child))
          )
        )
        (* self:rule24 *) Forall ?parent ?child (
          ?parent["give-inheritance"^^rif:local -> ?child] :-
          And (
            Or (
              ?parent[rif:op -> ?child]
              ?parent[rif:object -> ?child]
              ?parent[rif:left -> ?child]
              ?parent[rif:right -> ?child]
              ?parent[rif:sub -> ?child]
              ?parent[rif:super -> ?child]
              ?parent[rif:class -> ?child]
              ?parent[rif:instance -> ?child]
              ?parent[rif:target -> ?child]
              ?parent[rif:rest -> ?child]
            )
            Or (
              ?child # rif:Var
              Exists ?x (?child[rif:constname -> ?x])
            )
          )
        )
      )
      (* self:finalpropagate *) Group (
        (* self:rule25 *) Forall ?rifformula ?term ?target (
          ?term[ex:inherits-data -> ?target] :-
          And(
            ?rifformula # modelA:ConditionGenerator
            Or (
              ?rifformula[rif:left -> ?term]
              ?rifformula[rif:right -> ?term]
            )
            ?term["give-inheritance"^^rif:local -> ?target]
            ?target # rif:Var
          )
        )

        (* self:rule26 *) Forall ?rifnot ?target (
          ?rifnot[ex:inherits-data -> ?target] :-
          And (
            ?rifnot["give-inheritance"^^rif:local -> ?target]
            ?target # rif:Var
            Or (
              ?rifnot # rif:Or
              ?rifnot # rif:INeg
              ?rifnot # rif:Exists
            )
          )
        )
        (* self:rule27 *) Forall ?rifconstraint ?target (
          ?rifconstraint[ex:inherits-data -> ?target] :-
          And (
            ?rifconstraint["give-inheritance"^^rif:local -> ?target]
            ?rifconstraint # rif:External
            Or (
              ?rifconstraint # modelA:ConstraintGenerator
              ?rifconstraint # modelA:ConditionGenerator
            )
          )
        )
        (* self:rule28 *) Forall ?parent ?target ?child ?var ?name ?varlist (
          ?var[ex:inherits-data -> ?target] :-
          And (
            ?parent[rif:formula -> ?child]
            ?child["give-inheritance"^^rif:local -> ?target]
            ?target[rif:varname -> ?name]
            ?parent[rif:vars -> ?varlist]
            ?var[rif:varname -> ?name]
            External(pred:list-contains(?varlist ?var))
          )
        )
        (* self:rule29 *) Forall ?document ?localconst (
          ?document[ex:inherits-data -> ?localconst] :-
          And (
            ?document # rif:Document
            ?document["give-inheritance"^^rif:local -> ?localconst]
          )
        )
        (* self:rule30 *) Forall ?document ?localconst ?group (
          ?document[ex:inherits-data -> ?localconst] :-
          And (
            ?document[rif:payload -> ?group]
            ?group["give-inheritance"^^rif:local -> ?localconst]
          )
        )
        (* self:rule31 *) Forall ?var ?rifdo ?actionvar ?assign (
          ?var # modelA:NewVar :-
          And (
            ?rifdo[rif:actionVar -> ?actionvar]
            ?var # rif:Var
            ?var = External(func:get(?actionvar 0))
            ?assign # rif:New
            ?assign = External(func:get(?actionvar 1))
          )
        )
        (* self:rule32 *) Forall ?parent ?target ?var ?name ?actionvar(
          ?var[ex:inherits-data -> ?target] :-
          And (
            ?target["rifdoinheritance"^^rif:local -> ?parent]
            ?target[rif:varname -> ?name]
            ?parent[rif:actionVar -> ?actionvar]
            ?var[rif:varname -> ?name]
            ?var = External(func:get(?actionvar 0))
          )
        )
      )
      (* self:normalpropagate *) Group (
        (* self:rule33 *) Forall ?parent ?slotlist ?child ?slot ?target (
          ?parent["give-inheritance"^^rif:local -> ?target] :- 
          And (
            ?parent[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            Or (
              ?slot[rif:slotkey -> ?child]
              ?slot[rif:slotvalue -> ?child]
            )
            External(pred:list-contains(?slotlist ?slot))
            ?child["give-inheritance"^^rif:local -> ?target]
          )
        )
        (* self:rule34 *) Forall ?parent ?childlist ?child ?target(
          ?parent["give-inheritance"^^rif:local -> ?target] :- 
          And (
            Or (
              ?parent[rif:args -> ?childlist]
              ?parent[rif:formulas -> ?childlist]
              ?parent[rif:sentences -> ?childlist]
            )
            External(pred:is-list(?childlist))
            ?child["give-inheritance"^^rif:local -> ?target]
            External(pred:list-contains(?childlist ?child))
          )
        )
        (* self:rule35 *) Forall ?parent ?child ?target (
          ?parent["give-inheritance"^^rif:local -> ?target] :-
          And (
            Or (
              ?parent[rif:object -> ?child]
              ?parent[rif:if -> ?child]
              ?parent[rif:then -> ?child]
              ?parent[rif:target -> ?child]
              ?parent[rif:op -> ?child]
              ?parent[rif:pattern -> ?child]
              ?parent[rif:left -> ?child]
              ?parent[rif:right -> ?child]
              ?parent[rif:rest -> ?child]
              ?parent[rif:class -> ?child]
              ?parent[rif:instance -> ?child]
              ?parent[rif:sub -> ?child]
              ?parent[rif:super -> ?child]
              ?parent[rif:meta -> ?child]
              ?parent[rif:content -> ?child]
            )
            ?child["give-inheritance"^^rif:local -> ?target]
          )
        )
        (* self:rule36 *) Forall ?parent ?target ?child (
          ?parent["give-inheritance"^^rif:local -> ?target] :-
          And (
            ?parent[rif:formula -> ?child]
            ?child["give-inheritance"^^rif:local -> ?target]
            Not ( Exists ?var ?name ?varlist ( And (
              ?target[rif:varname -> ?name]
              ?parent[rif:vars -> ?varlist]
              ?var[rif:varname -> ?name]
              External(pred:list-contains(?varlist ?var))
            )))
          )
        )
        (* self:rule37 *) Forall ?parent ?target (
          ?parent["give-inheritance"^^rif:local -> ?target] :-
          And (
            ?target["rifdoinheritance"^^rif:local -> ?parent]
            Not ( Exists ?var ?name ?actionvar ( And (
              ?target[rif:varname -> ?name]
              ?parent[rif:actionVar -> ?actionvar]
              ?var[rif:varname -> ?name]
              ?var = External(func:get(?actionvar 0))
            )))
          )
        )
      )
      (* self:rule16 *) Forall ?rifforall ?varlist ?rifvar (
        If And (
          "always-wrong"^^rif:local()
          ?rifforall[rif:vars -> ?varlist]
          External(pred:is-list(?varlist))
          ?rifvar # rif:Var
          External(pred:list-contains(?varlist ?rifvar))
        ) Then Do (
          Assert( ?rifvar[ex:inherits-data -> ?rifforall] )
        )
      )
      (* self:rule07 *) Forall ?parent ?child (
        If And (
          "always-wrong"^^rif:local()
          Or (
            ?parent[rif:formula -> ?child]
            ?parent[rif:object -> ?child]
            ?parent[rif:if -> ?child]
            ?parent[rif:then -> ?child]
            ?parent[rif:target -> ?child]
            ?parent[rif:op -> ?child]
            ?parent[rif:payload -> ?child]
            ?parent[rif:pattern -> ?child]
            ?parent[rif:left -> ?child]
            ?parent[rif:right -> ?child]
            ?parent[rif:rest -> ?child]
            ?parent[rif:class -> ?child]
            ?parent[rif:instance -> ?child]
            ?parent[rif:sub -> ?child]
            ?parent[rif:super -> ?child]
            ?parent[rif:meta -> ?child]
          )
          Not( Exists ?x ( Or (
            ?child[rif:constIRI -> ?x]
            ?child[rif:value -> ?x]
          )))
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?child] )
        )
      )
      (* self:rule09 *) Forall ?parent ?atom ?childlist ?child (
        If And (
          "always-wrong"^^rif:local()
          ?parent[rif:content -> ?atom]
          ?atom[rif:args -> ?childlist]
          External(pred:is-list(?childlist))
          Or (
            ?child # rif:Var
            ?child # rif:Const
            ?child # rif:List
            ?child # rif:External
          )
          Not(Exists ?x ( Or(
            ?child[rif:constIRI -> ?x]
            ?child[rif:value -> ?x]
          )))
          External(pred:list-contains(?childlist ?child))
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?child] )
        )
      )
      (* self:rule38 *) Forall ?rifdo ?actionvar ?binding (
        If And (
          "always-wrong"^^rif:local()
          ?rifdo[rif:actionVar -> ?actionvar]
          External(pred:is-list(?actionvar))
          ?binding # rif:Frame
          External(pred:list-contains(?actionvar ?binding))
        ) Then Do (
          Assert( ?rifdo[ex:inherits-data -> ?binding] )
        )
      )
      (* self:rule10 *) Forall ?parent ?slotlist ?slot ?childkey (
        If And (
          "always-wrong"^^rif:local()
          ?parent[rif:slots -> ?slotlist]
          External(pred:is-list(?slotlist))
          ?slot[rif:slotkey -> ?childkey]
          Not( Exists ?x ( Or (
            ?childkey[rif:constIRI -> ?x]
            ?childkey[rif:value -> ?x]
          )))
          External(pred:list-contains(?slotlist ?slot))
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?childkey] )
        )
      )
      (* self:rule11 *) Forall ?parent ?slotlist ?slot ?childvalue (
        If And (
          "always-wrong"^^rif:local()
          ?parent[rif:slots -> ?slotlist]
          External(pred:is-list(?slotlist))
          ?slot[rif:slotvalue -> ?childvalue]
          Not( Exists ?x ( Or (
            ?childvalue[rif:constIRI -> ?x]
            ?childvalue[rif:value -> ?x]
          )))
          External(pred:list-contains(?slotlist ?slot))
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?childvalue] )
        )
      )
      (* self:rule12 *) Forall ?parent ?childlist ?child (
        If And (
          "always-wrong"^^rif:local()
          Or (
            ?parent[rif:sentences -> ?childlist]
            ?parent[rif:formulas -> ?childlist]
            ?parent[rif:actions -> ?childlist]
            ?parent[rif:args -> ?childlist]
            ?parent[rif:items -> ?childlist]
          )
          External(pred:is-list(?childlist))
          Or (
            ?child # rif:Group
            ?child # rif:Forall
            ?child # rif:Frame
            ?child # rif:Atom
            ?child # rif:Assert
            ?child # rif:Retract
            ?child # rif:Do
            ?child # rif:Modify
            ?child # rif:Subclass
            ?child # rif:Equal
            ?child # rif:Member
            ?child # rif:Var
            ?child # rif:Const
            ?child # rif:List
            ?child # rif:And
            ?child # rif:INeg
            ?child # rif:Or
            ?child # rif:Not
            ?child # rif:Exists
            ?child # rif:External
            ?child # rif:Execute
          )
          Not( Exists ?x ( Or (
            ?child[rif:constIRI -> ?x]
            ?child[rif:value -> ?x]
          )))
          External(pred:list-contains(?childlist ?child))
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?child] )
        )
      )
      (* self:rule14 *) Forall ?parent ?child ?grandchild (
        If And (
          "always-wrong"^^rif:local()
          ?parent[ex:inherits-data -> ?child]
          ?child[ex:inherits-data -> ?grandchild]
          Or (
            ?grandchild # rif:Const
            ?grandchild # rif:Var
            ?grandchild # rif:INeg
          )
        ) Then Do (
          Assert( ?parent[ex:inherits-data -> ?grandchild])
        )
      )
    )
)
