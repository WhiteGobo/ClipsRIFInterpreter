Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(ex <http://example.com/>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Group (
      Forall ?defrule ?conditionallist ?pattern ?bindsvar (
        If And (
          ?defrule[rdf:type -> cs:Defrule]
          ?defrule[cs:conditional-element -> ?conditionallist]
          External(pred:is-list(?conditionallist))
          ?pattern[ex:binds-variable -> ?bindsvar]
          External(pred:list-contains(?conditionallist ?pattern))
        ) Then Do (
          Assert( ?defrule[ex:bound-variable -> ?bindsvar] )
        )
      )
      Forall ?templatepattern ?slotlist ?var ?varname (
        If And (
          ?templatepattern[cs:slot -> ?slotlist]
          External(pred:is-list(?slotlist))
          ?slot[cs:constraint -> ?var]
          External(pred:list-contains(?slotlist ?slot))
          ?var[cs:variable-name -> ?varname]
        ) Then Do (
          Assert( ?templatepattern[ex:binds-variable -> ?var] )
        )
      )
      Forall ?constraint ?defrule ?var (
        If And(
          ?defrule[ex:transfer-bound-variables-from -> ?constraint]
          ?constraint[ex:binds-variable -> ?var]
        ) Then Do (
          Assert( ?defrule[ex:bound-variable -> ?var] )
        )
      )
      Forall ?content ?rifop ?rifarglist ?functionname ?functionsymbol (
        If And (
          ?rifexternal[rdf:type -> rif:External]
          ?rifexternal[rif:content -> ?content]
          ?content[rif:op -> ?rifop]
          ?rifop[ex:as-expression -> ?functionsymbol]
          ?functionsymbol[cs:symbol -> ?functionname]
          ?content[rif:args -> ?rifarglist]
          External(pred:is-list(?rifarglist))
        ) Then Do (
          (?function New())
          Assert( ?rifexternal[ex:as-action -> External(func:make-list(?function))] )
          Assert( ?rifexternal[ex:as-expression -> ?function] )
          Assert( ?function[cs:function-name -> ?functionname] )
          Assert( ?function[cs:function-args -> External(func:make-list())] )
          Assert( ?function[ex:add-args-from -> ?rifarglist] )
        )
      )
      Group 10 (
        Forall ?function ?rifarglist ?firstarg (
          If And (
            ?function[ex:add-args-from -> ?rifarglist]
            External(pred:is-list(?rifarglist))
            ?firstarg[ex:as-expression -> ?clipsexpression]
            ?firstarg = External(func:get(?rifarglist 0))
          ) Then Do (
            (?functionargs ?function[cs:function-args -> ?functionargs])
            Modify(?function[cs:function-args -> External(func:append(?functionargs ?clipsexpression))])
            Modify(?function[ex:add-args-from -> External(func:remove(?rifarglist 0))])
          )
        )
      )
      Group -1 (
        Forall ?rifexternal ?action ?defrule (
          If And (
            ?rifexternal[ex:add-as-pattern -> ?defrule]
            ?rifexternal[rdf:type -> rif:External]
            ?rifexternal[ex:as-expression -> ?action]
            Not (Exists ?var ( And(
              ?action[ex:needs-variable -> ?var]
              Not (?defrule[ex:bound-variable -> ?var])
            )))
          ) Then Do (
            (?pattern New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert( ?pattern[rdf:type -> cs:TestCE] )
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert(?pattern[cs:function-call -> ?action])
          )
        )

        Forall ?rifequal ?action ?defrule ?left ?right ?leftexpr ?rightexpr (
          If And (
            ?rifequal[ex:add-as-pattern -> ?defrule]
            ?rifequal[rif:left -> ?left]
            ?rifequal[rif:right -> ?right]
            ?left[ex:as-expression -> ?leftexpr]
            ?right[ex:as-expression -> ?rightexpr]
            Not( Exists ?varname (
              ?leftexpr[cs:variable-name -> ?varname]
            ))
            Not( Exists ?varname (
              ?rightexpr[cs:variable-name -> ?varname]
            ))
          ) Then Do (
            (?pattern New())
            (?action New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert( ?pattern[rdf:type -> cs:TestCE] )
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert(?pattern[cs:function-call -> ?action])
            Assert(?action[cs:function-name -> "eq"])
            Assert(?action[cs:function-args -> External(func:make-list( ?leftexpr ?rightexpr))])
          )
        )

        Forall ?rifatom ?op ?defrule ?arglist ?constraintop (
          If And (
            ?rifatom[ex:add-as-pattern -> ?defrule]
            ?rifatom[rif:op -> ?op]
            ?rifatom[rif:args -> ?arglist]
            External(pred:is-list(?arglist))
            ?op[ex:as-constraint -> ?constraintop]
          ) Then Do (
            (?pattern New())
            (?slotop New())
            (?slotargs New())
            Assert( ?rifatom[ex:as-lhs-pattern -> ?pattern] )
            Assert( ?pattern[rdf:type -> cs:TemplatePatternCE])
            Assert( ?pattern[cs:deftemplate-name -> "Atom"] )
            Assert( ?pattern[cs:slot -> External(func:make-list(?slotop ?slotargs))] )
            Assert( ?slotop[cs:slot-name -> "op"] )
            Assert( ?slotop[cs:constraint -> ?constraintop] )
            Assert( ?slotargs[cs:slot-name -> "args"] )
            Assert( ?slotargs[cs:constraints -> External(func:make-list())] )
            Assert( ?slotargs[ex:add-atom-args -> ?arglist] )
          )
        )
        Group 10 (
          Forall ?slotargs ?arglist ?firstarg ?clipsexpr(
            If And (
              ?slotargs[ex:add-atom-args -> ?arglist]
              ?firstarg[ex:as-expression -> ?clipsexpr]
              ?firstarg = External(func:get(?arglist 0))
            ) Then Do (
              (?oldconstraints ?slotargs[cs:constraints -> ?oldconstraints])
              Modify(?slotargs[ex:add-atom-args -> External(func:remove(?arglist 0))])
              Modify( ?slotargs[cs:constraints -> External(func:append(?oldconstraints ?clipsexpr))] )
            )
          )
          Forall ?slotargs (
            If ?slotargs[ex:add-atom-args -> List()]
            Then Do(Retract(?slotargs[ex:add-atom-args -> List()]))
          )
        )
        Forall ?defrule ?rifatom ?slotargs (
          If And (
            ?rifatom[ex:add-as-pattern -> ?defrule]
            ?rifatom[rdf:type -> rif:Atom]
            ?rifatom[ex:as-lhs-pattern -> ?pattern]
            ?pattern[cs:slot -> ?slotlist]
            ?slotargs[cs:constraints -> ?slotargsconstraints]
            External(pred:list-contains(?slotlist ?slotargs))
            Not( ?slotargs[ex:add-atom-args -> ?arglist] )
            Not (Exists ?x ?singleconstraint( And(
              ?singleconstraint[ex:needs-variable -> ?x]
              External(pred:list-contains(?slotargsconstraints ?singleconstraint))
              Not( ?defrule[ex:bound-variable -> ?x] )
            )))
          ) Then Do (
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
          )
        )

        Forall ?rifframe ?slot ?defrule ?slotkey ?slotvalue (
          If And (
            ?rifframe[ex:add-as-pattern -> ?defrule]
            ?rifframe[rif:object -> ?frameobject]
            ?rifframe[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            ?slot[rif:slotkey -> ?slotkey]
            ?slot[rif:slotvalue -> ?slotvalue]
            External(pred:list-contains(?slotlist ?slot))
            ?frameobject[ex:as-constraint -> ?constraintsubject]
            ?slotkey[ex:as-constraint -> ?constraintpredicate]
            ?slotvalue[ex:as-constraint -> ?constraintobject]
            Not (Exists ?x ( And(
              ?constraintsubject[ex:needs-variable -> ?x]
              Not( ?defrule[ex:bound-variable -> ?x] )
            )))
            Not (Exists ?y ( And(
              ?constraintpredicate[ex:needs-variable -> ?y]
              Not( ?defrule[ex:bound-variable -> ?y] )
            )))
            Not (Exists ?z ( And(
              ?constraintobject[ex:needs-variable -> ?z]
              Not( ?defrule[ex:bound-variable -> ?z] )
            )))
          ) Then Do (
            (?pattern New())
            (?slotsubject New())
            (?slotpredicate New())
            (?slotobject New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert( ?pattern[rdf:type -> cs:TemplatePatternCE])
            Assert( ?pattern[cs:deftemplate-name -> "TripleTemplate"] )
            Assert( ?pattern[cs:slot -> External(func:make-list(?slotsubject ?slotpredicate ?slotobject))] )
            Assert( ?slotsubject[cs:slot-name -> "subject"] )
            Assert( ?slotsubject[cs:constraint -> ?constraintsubject])
            Assert( ?slotpredicate[cs:slot-name -> "predicate"] )
            Assert( ?slotpredicate[cs:constraint -> ?constraintpredicate])
            Assert( ?slotobject[cs:slot-name -> "object"] )
            Assert( ?slotobject[cs:constraint -> ?constraintobject])
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintsubject])
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintpredicate])
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintobject])
          )
        )
      )

      Group 50 (
        Forall ?clipsfunction ?arglist ?arg ?varname (
          If And (
            ?clipsfunction[cs:function-args -> ?arglist]
            External(pred:is-list(?arglist))
            ?arg[cs:variable-name -> ?varname]
            External(pred:list-contains(?arglist ?arg))
          ) Then Do (
            Assert( ?clipsfunction[ex:needs-variable -> ?arg] )
          )
        )
      )
    )
)
