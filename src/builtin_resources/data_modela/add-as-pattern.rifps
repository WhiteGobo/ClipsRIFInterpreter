Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(ex <http://example.com/>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Group (
      (* ex:errordiagnose-in-pattern-creation *) Group -100 (
        Forall ?defrule ?formula (
          If And (
            ?rifatom[ex:add-as-pattern -> ?defrule]
            Not(?rifatom[ex:used-as-pattern-in -> ?defrule])
          ) Then Do (
            Execute(crifi:set-graph-in-errorstate("A pattern wasnt used in defrule"))
          )
        )
      )
      Forall ?defrule ?conditionallist ?pattern ?bindsvar (
        If And (
          ?defrule # cs:Defrule
          ?defrule[cs:conditional-element -> ?conditionallist]
          External(pred:is-list(?conditionallist))
          ?pattern[ex:binds-variable -> ?bindsvar]
          External(pred:list-contains(?conditionallist ?pattern))
        ) Then Do (
          Assert( ?defrule[ex:bound-variable -> ?bindsvar] )
        )
      )
      Forall ?templatepattern ?slotlist ?var ?constraintlist(
        If And (
          ?templatepattern[cs:slot -> ?slotlist]
          External(pred:is-list(?slotlist))
          ?slot[cs:constraints -> ?constraintlist]
          External(pred:list-contains(?slotlist ?slot))
          External(pred:is-list(?constraintlist))
          ?var # cs:Variable
          External(pred:list-contains(?constraintlist ?var))
        ) Then Do (
          Assert( ?templatepattern[ex:binds-variable -> ?var] )
        )
      )
      Forall ?templatepattern ?slotlist ?var (
        If And (
          ?templatepattern[cs:slot -> ?slotlist]
          External(pred:is-list(?slotlist))
          ?slot[cs:constraint -> ?var]
          External(pred:list-contains(?slotlist ?slot))
          ?var # cs:Variable
        ) Then Do (
          Assert( ?templatepattern[ex:binds-variable -> ?var] )
        )
      )
      Forall ?constraint ?defrule ?var (
        If And(
          ?defrule[ex:transfer-bound-variables-from -> ?constraint]
          ?constraint[ex:binds-variable -> ?var]
        ) Then Do (
          Assert( ?defrule[ex:bound-variable -> ?var] )
        )
      )
      Group -1 (
        Forall ?rifexternal ?action ?defrule (
          If And (
            ?rifexternal[ex:add-as-pattern -> ?defrule]
            ?rifexternal # rif:External
            ?rifexternal[ex:as-expression -> ?action]
            Not (Exists ?var ( And(
              ?action[ex:needs-variable -> ?var]
              Not (?defrule[ex:bound-variable -> ?var])
            )))
          ) Then Do (
            (?pattern New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert( ?pattern # cs:TestCE )
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert( ?rifexternal[ex:used-as-pattern-in -> ?defrule])
            Assert( ?pattern[cs:function-call -> ?action] )
          )
        )

        Group -1 (
          Forall ?rifequal ?action ?defrule ?left ?right ?leftexpr ?rightexpr (
            If And (
              ?rifequal[ex:add-as-pattern -> ?defrule]
              ?rifequal[rif:left -> ?left]
              ?rifequal[rif:right -> ?right]
              ?left[ex:as-expression -> ?leftexpr]
              ?right[ex:as-expression -> ?rightexpr]
              ?leftexpr # cs:Variable
              Not( ?defrule[ex:bound-variable -> ?leftexpr] )
              Not (Exists ?var ( And(
                ?rightexpr[ex:needs-variable -> ?var]
                Not (?defrule[ex:bound-variable -> ?var])
              )))
              Not ( And (
                ?rightexpr # cs:Variable
                Not( ?defrule[ex:bound-variable -> ?rightexpr] )
              ))
            ) Then Do (
              Assert( ?rifequal[ex:used-as-pattern-in -> ?defrule] )
              Assert( ?leftexpr[cs:var-as-const-expr -> ?rightexpr] )
              Assert( ?defrule[ex:bound-variable -> ?leftexpr] )
            )
          )

          Forall ?rifequal ?action ?defrule ?left ?right ?leftexpr ?rightexpr (
            If And (
              ?rifequal[ex:add-as-pattern -> ?defrule]
              ?rifequal[rif:left -> ?left]
              ?rifequal[rif:right -> ?right]
              ?left[ex:as-expression -> ?leftexpr]
              ?right[ex:as-expression -> ?rightexpr]
              ?rightexpr # cs:Variable
              Not( ?defrule[ex:bound-variable -> ?rightexpr] )
              Not (Exists ?var ( And(
                ?leftexpr[ex:needs-variable -> ?var]
                Not (?defrule[ex:bound-variable -> ?var])
              )))
              Not ( And (
                ?leftexpr # cs:Variable
                Not( ?defrule[ex:bound-variable -> ?leftexpr] )
              ))
            ) Then Do (
              Assert( ?rifequal[ex:used-as-pattern-in -> ?defrule] )
              Assert( ?rightexpr[cs:var-as-const-expr -> ?leftexpr] )
              Assert( ?defrule[ex:bound-variable -> ?rightexpr] )
            )
          )
        )

        Forall ?rifequal ?action ?defrule ?left ?right ?leftexpr ?rightexpr (
          If And (
            ?rifequal[ex:add-as-pattern -> ?defrule]
            ?rifequal[rif:left -> ?left]
            ?rifequal[rif:right -> ?right]
            ?left[ex:as-expression -> ?leftexpr]
            ?right[ex:as-expression -> ?rightexpr]
            Not( ?leftexpr # cs:Variable )
            Not( ?rightexpr # cs:Variable )
          ) Then Do (
            (?pattern New())
            (?action New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert( ?pattern # cs:TestCE )
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert( ?rifequal[ex:used-as-pattern-in -> ?defrule])
            Assert(?pattern[cs:function-call -> ?action])
            Assert(?action[cs:function-name -> "eq"])
            Assert(?action[cs:function-args -> External(func:make-list( ?leftexpr ?rightexpr))])
          )
        )

        Forall ?rifatom ?op ?defrule ?arglist ?constraintop (
          If And (
            ?rifatom[ex:add-as-pattern -> ?defrule]
            ?rifatom[rif:op -> ?op]
            ?rifatom[rif:args -> ?arglist]
            External(pred:is-list(?arglist))
            ?op[ex:as-constraint -> ?constraintop]
          ) Then Do (
            (?pattern New())
            (?slotop New())
            (?slotargs New())
            Assert( ?rifatom[ex:as-lhs-pattern -> ?pattern] )
            Assert( ?pattern # cs:TemplatePatternCE )
            Assert( ?pattern[cs:deftemplate-name -> "Atom"] )
            Assert( ?pattern[cs:slot -> External(func:make-list(?slotop ?slotargs))] )
            Assert( ?slotop[cs:slot-name -> "op"] )
            Assert( ?slotop[cs:constraint -> ?constraintop] )
            Assert( ?slotargs[cs:slot-name -> "args"] )
            Assert( ?slotargs[cs:constraints -> External(func:make-list())] )
            Assert( ?slotargs[ex:add-atom-args -> ?arglist] )
          )
        )
        Group 10 (
          Forall ?slotargs ?arglist ?firstarg ?clipsexpr(
            If And (
              ?slotargs[ex:add-atom-args -> ?arglist]
              ?firstarg[ex:as-expression -> ?clipsexpr]
              ?firstarg = External(func:get(?arglist 0))
            ) Then Do (
              (?oldconstraints ?slotargs[cs:constraints -> ?oldconstraints])
              Modify(?slotargs[ex:add-atom-args -> External(func:remove(?arglist 0))])
              Modify( ?slotargs[cs:constraints -> External(func:append(?oldconstraints ?clipsexpr))] )
            )
          )
          Forall ?slotargs (
            If ?slotargs[ex:add-atom-args -> List()]
            Then Do(Retract(?slotargs[ex:add-atom-args -> List()]))
          )
        )
        Forall ?defrule ?rifatom ?slotargs (
          If And (
            ?rifatom[ex:add-as-pattern -> ?defrule]
            ?rifatom # rif:Atom
            ?rifatom[ex:as-lhs-pattern -> ?pattern]
            ?pattern[cs:slot -> ?slotlist]
            ?slotargs[cs:constraints -> ?slotargsconstraints]
            External(pred:list-contains(?slotlist ?slotargs))
            Not( ?slotargs[ex:add-atom-args -> ?arglist] )
            Not (Exists ?x ?singleconstraint( And(
              ?singleconstraint[ex:needs-variable -> ?x]
              External(pred:list-contains(?slotargsconstraints ?singleconstraint))
              Not( ?defrule[ex:bound-variable -> ?x] )
            )))
          ) Then Do (
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert( ?rifatom[ex:used-as-pattern-in -> ?defrule])
          )
        )

        Forall ?rifframe ?slot ?defrule ?slotkey ?slotvalue (
          If And (
            ?rifframe[ex:add-as-pattern -> ?defrule]
            ?rifframe[rif:object -> ?frameobject]
            ?rifframe[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            ?slot[rif:slotkey -> ?slotkey]
            ?slot[rif:slotvalue -> ?slotvalue]
            External(pred:list-contains(?slotlist ?slot))
            ?frameobject[ex:as-constraint -> ?constraintsubject]
            ?slotkey[ex:as-constraint -> ?constraintpredicate]
            ?slotvalue[ex:as-constraint -> ?constraintobject]
            Not (Exists ?x ( And(
              ?constraintsubject[ex:needs-variable -> ?x]
              Not( ?defrule[ex:bound-variable -> ?x] )
            )))
            Not (Exists ?y ( And(
              ?constraintpredicate[ex:needs-variable -> ?y]
              Not( ?defrule[ex:bound-variable -> ?y] )
            )))
            Not (Exists ?z ( And(
              ?constraintobject[ex:needs-variable -> ?z]
              Not( ?defrule[ex:bound-variable -> ?z] )
            )))
            Not(?slot[ex:used-as-pattern-in -> ?defrule])
          ) Then Do (
            (?pattern New())
            (?slotsubject New())
            (?slotpredicate New())
            (?slotobject New())
            (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
            Assert(?slot[ex:used-as-pattern-in -> ?defrule])
            Assert(?rifframe[ex:used-as-pattern-in -> ?defrule])

            Assert( ?pattern # cs:TemplatePatternCE )
            Assert( ?pattern[cs:deftemplate-name -> "TripleTemplate"] )
            Assert( ?pattern[cs:slot -> External(func:make-list(?slotsubject ?slotpredicate ?slotobject))] )
            Assert( ?slotsubject[cs:slot-name -> "subject"] )
            Assert( ?slotsubject[cs:constraint -> ?constraintsubject])
            Assert( ?slotpredicate[cs:slot-name -> "predicate"] )
            Assert( ?slotpredicate[cs:constraint -> ?constraintpredicate])
            Assert( ?slotobject[cs:slot-name -> "object"] )
            Assert( ?slotobject[cs:constraint -> ?constraintobject])
            Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?pattern))] )
            Assert( ?rifframe[ex:used-as-pattern-in -> ?defrule])
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintsubject])
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintpredicate])
            Assert( ?defrule[ex:transfer-bound-variables-from -> ?constraintobject])
          )
        )
      )
      Forall ?defrule ?rifineg ?formula ?clipsconditional (
        If And (
          ?rifineg[ex:add-as-pattern -> ?defrule]
          ?rifineg # rif:INeg
          ?rifineg[rif:formula -> ?formula]
          ?formula[ex:as-conditional -> ?clipsconditional]
        ) Then Do (
          (?notCE New())
          (?oldpatternlist ?defrule[cs:conditional-element -> ?oldpatternlist])
          Modify( ?defrule[cs:conditional-element -> External(func:append(?oldpatternlist ?notCE))] )
          Assert( ?rifineg[ex:used-as-pattern-in -> ?defrule])
          Assert( ?rifineg[ex:as-conditional -> External(func:make-list(?notCE))])
          Assert( ?notCE # cs:NotCE )
          Assert( ?notCE[cs:conditional-element -> ?clipsconditional] )
        )
      )

      Group 50 (
        Forall ?clipsfunction ?arglist ?arg (
          If And (
            ?clipsfunction[cs:function-args -> ?arglist]
            External(pred:is-list(?arglist))
            ?arg # cs:Variable
            External(pred:list-contains(?arglist ?arg))
          ) Then Do (
            Assert( ?clipsfunction[ex:needs-variable -> ?arg] )
          )
        )
      )
    )
)
