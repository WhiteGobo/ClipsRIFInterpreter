Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(modelA <http://white.gobo/modelA#>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Prefix(ex <http://example.com/>)
    Prefix(exa <http://example.com/a#>)
    Prefix(self <http://example.com/variable-binding#>)
    Group 5 (
      Group -100 (
        (* self:rule75 *) Forall ?rif ?pattern (
          If And (
            ?rif["add-pattern-from"^^rif:local -> ?pattern]
            Not( ?rif["added-pattern-from"^^rif:local -> ?pattern] )
          ) Then Do (
            Assert(?pattern # ex:misses-bound-variables)
            Assert(?rif[ex:misses-pattern-for -> ?pattern])
            Execute(crifi:set-graph-in-errorstate("Dont know where to add pattern for a formula(ex:misses-bound-variables)"))
          )
        )
        (* self:rule63 *) Forall ?formulacontainer ?formulalist (
          If And (
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            External(pred:numeric-greater-than(External(func:count(?formulalist)) 0))
          ) Then Do (
            Assert(External(func:get(?formulalist 0)) # ex:couldnt-translate-to-pattern)
            Assert(?formulacontainer # ex:missing-translated-pattern)
            Execute(crifi:set-graph-in-errorstate("Couldnt translate formula to pattern.(ex:couldnt-translate-to-pattern ex:missing-translated-pattern)"))
          )
        )
      )
      (* self:rule64 *) Forall ?formula (
        If Or (
          ?formula # rif:And
          ?formula # rif:Or
          ?formula # rif:Exists
          ?formula # rif:External
          ?formula # rif:INeg
          ?formula # rif:Frame
          ?formula # rif:Atom
          ?formula # rif:Member
          ?formula # rif:SubClass
          ?formula # rif:Equal
        ) Then Do( Assert(?formula # "rifformula"^^rif:local) )
      )
      (* self:rule65 *) Forall ?rifvar ?clipsconstraint (
        If And (
          ?rifvar # rif:Var
          ?rifvar[ex:as-constraint -> ?clipsconstraint]
        ) Then ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
      )
      (* self:rule66 *) Forall ?riflist ?itemlist ?rifvar ?clipsconstraint (
        If And (
          ?riflist # ex:ConstraintGenerator
          ?riflist[rif:items -> ?itemlist]
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          External(pred:list-contains(?itemlist ?rifvar))
        ) Then ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
      )
      (* self:rule67 *) Forall ?rifrule ?rifformula ?clipsconstraint (
        If And (
          ?rifrule[rif:formula -> ?rifformula]
          Or (
            ?rifformula # rif:Frame
            ?rifformula # rif:Atom
            ?rifformula # rif:External
            ?rifformula # rif:Equal
            ?rifformula # rif:Member
          )
          ?rifformula["bound-variable"^^rif:local -> ?clipsconstraint]
        ) Then Do (
          Assert( ?rifformula[modelA:bound-variable -> ?clipsconstraint] )
        )
      )
      (* self:rule68 *) Forall ?rifrule ?formulalist ?rifformula ?clipsconstraint (
        If And (
          ?rifrule # rif:And
          ?rifrule[rif:formulas -> ?formulalist]
          Or (
            ?rifformula # rif:Frame
            ?rifformula # rif:Atom
            ?rifformula # rif:External
            ?rifformula # rif:Equal
            ?rifformula # rif:Member
          )
          External(pred:list-contains(?formulalist ?rifformula))
          ?rifformula["bound-variable"^^rif:local -> ?clipsconstraint]
        ) Then Do (
          Assert( ?rifformula[modelA:bound-variable -> ?clipsconstraint] )
        )
      )
      (* self:rule69 *) Forall ?rifobj ?rifvar ?clipsconstraint (
        If And (
          Or (
            ?rifobj # modelA:TripleTemplateGenerator
            ?rifobj # modelA:MemberPatternGenerator
            ?rifobj # modelA:SubclassPatternGenerator
          )
          Or (
            ?rifobj[rif:object -> ?rifvar]
            ?rifobj[rif:slotkey -> ?rifvar]
            ?rifobj[rif:slotvalue -> ?rifvar]
            ?rifobj[rif:sub -> ?rifvar]
            ?rifobj[rif:super -> ?rifvar]
            ?rifobj[rif:class -> ?rifvar]
            ?rifobj[rif:instance -> ?rifvar]
          )
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          Not(?rifobj["bound-variable"^^rif:local -> ?clipsconstraint])
        ) Then ?rifobj[modelA:binds-var -> ?clipsconstraint]
      )
      (* self:rule70 *) Forall ?rifobj ?rifvar ?clipsconstraint (
        If And (
          ?rifobj # modelA:AtomPatternGenerator
          ?rifobj[rif:op -> ?rifvar]
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          Not(?rifobj["bound-variable"^^rif:local -> ?clipsconstraint])
        ) Then ?rifobj[modelA:binds-var -> ?clipsconstraint]
      )
      (* self:rule71 *) Forall ?rifformula ?clipsconstraint ?rifvar (
        If And (
          ?rifformula # modelA:PatternGenerator
          Or (
            ?rifformula[rif:left -> ?rifvar]
            ?rifformula[rif:right -> ?rifvar]
            ?rifformula[rif:op -> ?rifvar]
            ?rifformula[rif:instance -> ?rifvar]
            ?rifformula[rif:class -> ?rifvar]
            ?rifformula[rif:sub -> ?rifvar]
            ?rifformula[rif:super -> ?rifvar]
          )
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          Not(?rifformula["bound-variable"^^rif:local -> ?clipsconstraint])
        ) Then ?rifformula[modelA:binds-var -> ?clipsconstraint]
      )
      (* self:rule72 *) Forall ?riflist ?rifvar ?clipsconstraint (
        If And (
          ?riflist[rif:rest -> ?rifvar]
          ?riflist # modelA:ConstraintGenerator
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
        ) Then Do (
          Assert( ?riflist["constraint-binds-var"^^rif:local -> ?clipsconstraint] )
        )
      )
      (* self:rule73 *) Forall ?riflist ?itemlist ?rifvar ?clipsconstraint (
        If And (
          ?riflist[rif:items -> ?itemlist]
          ?riflist # modelA:ConstraintGenerator
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          External(pred:list-contains(?itemlist ?rifvar))
        ) Then Do (
          Assert( ?riflist["constraint-binds-var"^^rif:local -> ?clipsconstraint] )
        )
      )
      (* self:rule74 *) Forall ?rifformula ?clipsvar ?rifvar (
        If And (
          Or (
            ?rifformula[rif:object -> ?rifvar]
            ?rifformula[rif:left -> ?rifvar]
            ?rifformula[rif:right -> ?rifvar]
            ?rifformula[rif:op -> ?rifvar]
            ?rifformula[rif:content -> ?rifvar]
            ?rifformula[rif:instance -> ?rifvar]
            ?rifformula[rif:class -> ?rifvar]
            ?rifformula[rif:sub -> ?rifvar]
            ?rifformula[rif:super -> ?rifvar]
            ?rifformula[rif:slotkey -> ?rifvar]
            ?rifformula[rif:slotvalue -> ?rifvar]
          )
          ?rifvar["constraint-needs-var"^^rif:local -> ?clipsvar]
        ) Then ?rifformula["constraints-needs-variable"^^rif:local -> ?clipsvar]
      )
      (* self:rule10 *) Forall ?rifexternal ?rifatom ?arglist ?arg ?clipsvar (
        If And (
          ?rifexternal # rif:External
          ?rifexternal # modelA:PatternGenerator
          ?rifexternal[rif:content -> ?rifatom]
          ?rifatom[rif:args -> ?arglist]
          ?arg # rif:Var
          ?arg[ex:as-expression -> ?clipsvar]
          External(pred:list-contains(?arglist ?arg))
        ) Then Do (
          Assert(?rifexternal["constraints-needs-variable"^^rif:local -> ?clipsvar])
        )
      )
      (* self:rule11 *) Forall ?rifexternal ?rifatom ?arglist ?arg ?clipsvar (
        If And (
          ?rifexternal # rif:External
          ?rifexternal # modelA:PatternGenerator
          ?rifexternal[rif:content -> ?rifatom]
          ?rifatom[rif:args -> ?arglist]
          Or (
            ?arg # rif:External
            ?arg # rif:List
          )
          ?arg["expression-needs-var"^^rif:local -> ?clipsvar]
        ) Then Do (
          Assert(?rifexternal["constraints-needs-variable"^^rif:local -> ?clipsvar])
        )
      )
      (* self:rule13 *) Forall ?rifatom ?arglist ?rifvar ?clipsvar (
        If And (
          ?rifatom[rif:args -> ?arglist]
          ?rifvar["constraint-needs-var"^^rif:local -> ?clipsvar]
          External(pred:list-contains(?arglist ?rifvar))
        ) Then ?rifatom["constraints-needs-variable"^^rif:local -> ?clipsvar]
      )
      (* self:rule14 *) Forall ?rifframe ?clipsconstraint ?slotlist ?rifvar ?slot (
        If And (
          ?rifframe[rif:slots -> ?slotlist]
          ?rifframe # modelA:PatternGenerator
          ?slot # rif:Slot
          External(pred:list-contains(?slotlist ?slot))
          Or (
            ?slot[rif:slotkey -> ?rifvar]
            ?slot[rif:slotvalue -> ?rifvar]
          )
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          Not(?rifframe["bound-variable"^^rif:local -> ?clipsconstraint])
        ) Then ?rifframe[modelA:binds-var -> ?clipsconstraint]
      )
      (* self:rule15 *) Forall ?rifatom ?clipsconstraint ?arglist ?rifvar (
        If And (
          ?rifatom # modelA:PatternGenerator
          ?rifatom[rif:args -> ?arglist]
          ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          External(pred:list-contains(?arglist ?rifvar))
          Not(?rifatom["bound-variable"^^rif:local -> ?clipsconstraint])
        ) Then ?rifatom[modelA:binds-var -> ?clipsconstraint]
      )

      (* self:rule16 *) Forall ?rifor ?formulalist ?firstsubformula ?clipsconstraint (
        If And (
          ?rifor # rif:Or
          ?rifor[rif:formulas -> ?formulalist]
          ?firstsubformula[modelA:binds-var -> ?clipsconstraint]
          ?firstsubformula = External(func:get(?formulalist 0))
          Not( Exists ?otherformula ( And(
            ?otherformula # "rifformula"^^rif:local
            External(pred:list-contains(?formulalist ?otherformula))
            Not (?otherformula[modelA:binds-var -> ?clipsconstraint])
          )))
        ) Then ?rifor[modelA:binds-var -> ?clipsconstraint]
      )
      (* self:rule17 *) Forall ?rifand ?formulalist ?subformula ?clipsconstraint (
        If And (
          ?rifand # rif:And
          ?rifand[rif:formulas -> ?formulalist]
          ?rifand["added-pattern-from"^^rif:local -> ?subformula]
          ?subformula[modelA:binds-var -> ?clipsconstraint]
          External(pred:list-contains(?formulalist ?subformula))
        ) Then ?rifand[modelA:binds-var -> ?clipsconstraint]
      )

      (* self:rule18 *) Forall ?x (
        If ?x # modelA:ConditionGenerator Then "check-binding"^^rif:local(?x)
      )
      (* self:rule19 *) Forall ?parent ?x ?slotlist ?slot (
        If And (
          ?parent # modelA:ConditionGenerator
          ?parent[rif:slots -> ?slotlist]
          Or (
            ?slot[rif:slotkey -> ?x]
            ?slot[rif:slotvalue -> ?x]
          )
          External(pred:list-contains(?slotlist ?slot))
        ) Then "check-binding"^^rif:local(?x)
      )
      (* self:rule20 *) Forall ?parent ?arglist ?x ?atom (
        If And (
          ?parent # modelA:ConditionGenerator
          ?parent[rif:content -> ?atom]
          ?atom[rif:args -> ?arglist]
          Or (
            ?x # rif:Var
            ?x # rif:External
            ?x # rif:List
          )
          External(pred:list-contains(?arglist ?x))
        ) Then "check-binding"^^rif:local(?x)
      )
      (* self:rule21 *) Forall ?parent ?arglist ?x (
        If And (
          ?parent # modelA:ConditionGenerator
          ?parent[rif:args -> ?arglist]
          Or (
            ?x # rif:Var
            ?x # rif:External
            ?x # rif:List
          )
          External(pred:list-contains(?arglist ?x))
        ) Then "check-binding"^^rif:local(?x)
      )
      (* self:rule22 *) Forall ?parent ?term (
        If And (
          ?parent # modelA:ConditionGenerator
          Or (
            ?parent[rif:op -> ?term]
            ?parent[rif:subject -> ?term]
            ?parent[rif:left -> ?term]
            ?parent[rif:right -> ?term]
            ?parent[rif:sub -> ?term]
            ?parent[rif:super -> ?term]
          )
        ) Then Do(
          Assert( "check-binding"^^rif:local(?term) )
        )
      )

      (* self:rule23 *) Forall ?rifvar ?clipsexpression (
        If And (
          "check-binding"^^rif:local(?rifvar)
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsexpression]
        ) Then Do (
          Assert( ?rifvar["expression-needs-var"^^rif:local -> ?clipsexpression])
        )
      )
      (* self:rule24 *) Forall ?rifvar ?clipsexpression ?rifterm (
        If And (
          "check-binding"^^rif:local(?rifterm)
          ?rifterm[ex:inherits-data -> ?rifvar]
          Not(?rifterm # rif:List)
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsexpression]
        ) Then Do(
          Assert( ?rifterm["constraint-needs-var"^^rif:local -> ?clipsexpression])
          Assert( ?rifterm["expression-needs-var"^^rif:local -> ?clipsexpression])
        )
      )
      (* self:rule25 *) Forall ?rifvar ?clipsexpression ?itemlist ?rifterm (
        If And (
          "check-binding"^^rif:local(?rifterm)
          ?rifterm[ex:inherits-data -> ?rifvar]
          ?rifterm # rif:List
          ?rifterm[rif:items -> ?itemlist]
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsexpression]
          Not( External(pred:list-contains(?itemlist ?rifvar)) )
        ) Then Do(
          Assert( ?rifterm["expression-needs-var"^^rif:local -> ?clipsexpression])
        )
      )
      (* self:rule26 *) Forall ?riflist ?rifvar ?clipsexpression ?itemlist (
        If And (
          ?riflist # modelA:ExpressionGenerator
          ?riflist[rif:items -> ?itemlist]
          ?rifvar["expression-needs-var"^^rif:local -> ?clipsexpression]
          External(pred:list-contains(?itemlist ?rifvar))
        ) Then ?rifvar["expression-needs-var"^^rif:local -> ?clipsexpression]
      )

      (* self:rule27 *) Forall ?group ?sentences ?rifrule (
        If And (
          ?group[rif:sentences -> ?sentences]
          Or (
            ?rifrule # rif:Implies
            ?rifrule # rif:Forall
          )
          External(pred:is-list(?sentences))
          External(pred:list-contains(?sentences ?rifrule))
        ) Then Do(
          (?defrule New())
          Assert(?rifrule["formulalist"^^rif:local -> List()])

          Assert(?rifrule[modelA:as-defrule -> ?defrule])
          Assert(?defrule # cs:Defrule)
          Assert(?defrule[cs:conditional-element -> List()])
        )
      )
      (* self:rule28 *) Forall ?formula (
        If And (
          ?formula # rif:Or
        ) Then Do(
          (?clipsor New())
          Assert(?formula["formulalist"^^rif:local -> List()])

          Assert(?formula[modelA:as-lhs-pattern -> ?clipsor])
          Assert(?clipsor # cs:OrCE)
          Assert(?clipsor[cs:conditional-element -> List()])
        )
      )
      (* self:rule29 *) Forall ?formula (
        If And (
          ?formula # rif:INeg
        ) Then Do(
          (?clipsnot New())
          Assert(?formula["formulalist"^^rif:local -> List()])
          Assert(?formula[modelA:as-lhs-pattern -> ?clipsnot])
          Assert(?clipsnot # cs:NotCE)
          Assert(?clipsnot[cs:conditional-element -> List()])
        )
      )
      Group 11 (
        (* self:rule80 *) Forall ?rifineg ?clipsvar ?rifvarconsumer (
          If And (
            ?rifineg # rif:INeg
            ?rifineg[ex:inherits-data -> ?rifvarconsumer]
            ?rifvarconsumer[ex:as-expression -> ?clipsvar]
          ) Then Do (
            Assert(?rifineg["constraints-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule81 *) Forall ?formula ?varlist ?rifvar ?clipsvar (
          If And (
            ?formula # rif:Exists
            ?formula[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
            ?formula[rif:vars -> ?varlist]
          ) Then Do (
            Assert(?formula["constraints-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule36 *) Forall ?pattern ?term ?clipsvar (
          If And (
            ?pattern # modelA:PatternGenerator
            ?pattern # rif:External
            ?pattern[ex:inherits-data -> ?term]
            ?term # rif:Var
            ?term[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?term["expression-needs-var"^^rif:local -> ?clipsvar] )
          )
        )
        (* self:rule12 *) Forall ?rifexternal ?rifvar ?clipsvar (
          If And (
            ?rifexternal # rif:External
            ?rifexternal # modelA:ConditionGenerator
            ?rifexternal[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
          ) Then ?rifexternal["expressions-needs-var"^^rif:local -> ?clipsvar]
        )
      )
      (* self:rule30 *) Forall ?formula (
        If And (
          ?formula # rif:Exists
        ) Then Do(
          (?clipsexists New())
          Assert(?formula["formulalist"^^rif:local -> List()])

          Assert(?formula[modelA:as-lhs-pattern -> ?clipsexists])
          Assert(?clipsexists # cs:ExistsCE)
          Assert(?clipsexists[cs:conditional-element -> List()])
        )
      )
      (* self:rule31 *) Forall ?rifand (
        If And (
          ?rifand # rif:And
          Not (Exists ?superand ?formulalist( And (
            ?superand[rif:formulas -> ?formulalist]
            ?superand # rif:And
            External(pred:list-contains(?formulalist ?rifand))
          )))
          Not (Exists ?superimply (
            ?superimply[rif:if -> ?rifand]
          ))
          Not ( Exists ?superrule (
            ?superrule[rif:pattern -> ?rifand]
          ))
        ) Then Do(
          (?clipsand New())
          Assert(?rifand["formulalist"^^rif:local -> List()])

          Assert(?rifand[modelA:as-lhs-pattern -> ?clipsand])
          Assert(?clipsand # cs:AndCE)
          Assert(?clipsand[cs:conditional-element -> List()])
        )
      )

      (* self:rule32 *) Forall ?formula ?rifand ?formulalist(
        If And (
          Or (
            ?formula # "rifformula"^^rif:local
            ?formula # rif:Member
          )
          Or (
            ?rifand # rif:And
            ?rifand # rif:Or
          )
          ?rifand[rif:formulas -> ?formulalist]
          External(pred:list-contains(?formulalist ?formula))
        ) Then Do (
          Assert( ?rifand["add-pattern-from"^^rif:local -> ?formula] )
        )
      )
      (* self:rule33 *) Forall ?rifobj ?formula (
        If Or (
          ?rifobj[rif:if -> ?formula]
          ?rifobj[rif:pattern -> ?formula]
          ?rifobj[rif:formula -> ?formula]
        ) Then Do (
          Assert( ?rifobj["add-pattern-from"^^rif:local -> ?formula] )
        )
      )
      Group 20 (
        (* self:rule34 *) Forall ?rifand ?otherrifand ?rifformula (
          If And (
            ?rifand["add-pattern-from"^^rif:local -> ?otherrifand]
            Or (
              ?rifand # rif:And
              ?rifand # rif:Not
            )
            ?otherrifand # rif:And
            ?otherrifand["add-pattern-from"^^rif:local -> ?rifformula]
          ) Then Do (
            Assert( ?otherrifand["added-pattern-from"^^rif:local -> ?rifformula] )
            Assert( ?rifand["added-pattern-from"^^rif:local -> ?otherrifand] )
            Assert( ?rifand["add-pattern-from"^^rif:local -> ?rifformula] )
          )
        )
        (* self:rule35 *) Forall ?rifforall ?rifrule ?rifformula (
          If And (
            ?rifforall["add-pattern-from"^^rif:local -> ?rifrule]
            Or (
              ?rifforall # rif:Forall
              ?rifforall # rif:Implies
            )
            Or (
              ?rifrule # rif:Forall
              ?rifrule # rif:Implies
              ?rifrule # rif:And
            )
            ?rifrule["add-pattern-from"^^rif:local -> ?rifformula]
          ) Then Do (
            Assert( ?rifrule["added-pattern-from"^^rif:local -> ?rifformula] )
            Assert( ?rifforall["added-pattern-from"^^rif:local -> ?rifrule] )
            Assert( ?rifforall["add-pattern-from"^^rif:local -> ?rifformula] )
          )
        )
      )

      (* self:rule90 *) Forall ?rifformula ?term ?rifvar ?clipsvar (
        If And (
          ?rifformula # modelA:ConditionGenerator
          Or (
            ?rifformula[rif:left -> ?term]
            ?rifformula[rif:right -> ?term]
          )
          ?term[ex:inherits-data -> ?rifvar]
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsvar]
        ) Then Do (
          Assert( ?term["expression-needs-var"^^rif:local -> ?clipsvar] )
        )
      )
      (* self:rule37 *) Forall ?expression ?rifvar ?clipsvar (
        If And (
          "always-wrong"^^rif:local()
          ?expression # modelA:ExpressionGenerator
          ?expression[ex:inherits-data -> ?rifvar]
          ?rifvar[ex:as-expression -> ?clipsvar]
          ?clipsvar # cs:Variable
          Not(?clipsvar # ex:ConstraintGenerator)
        ) Then Do (
          Assert( ?expression["expression-needs-var"^^rif:local -> ?clipsvar] )
        )
      )

      Group -1 (
        (* self:rule91 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ?formula # modelA:MultiPatternGenerator
            ?formula[modelA:as-multi-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
          ) Then Do (
            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?subpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule38 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            Not(?formula # modelA:MultiPatternGenerator)
            ?formula[modelA:as-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
            Not (Exists ?aftercondition (?formula[modelA:lhs-pattern-after-conditions -> ?aftercondition]))
          ) Then Do (
            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?subpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule39 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ?formula[modelA:as-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
            Exists ?x ( ?formula[modelA:lhs-pattern-after-conditions -> ?x] )
          ) Then Do (
            (?andpattern New())
            Assert( ?andpattern # cs:AndCE )
            Assert( ?andpattern[cs:conditional-element -> List(?subpattern)])
            Assert( ?formula["transfer-after-conditions"^^rif:local -> ?andpattern])

            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?andpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule40 *) Forall ?formula ?andpattern ?aftercondition ?conditions (
          If And (
            ?formula["transfer-after-conditions"^^rif:local -> ?andpattern]
            ?formula[modelA:lhs-pattern-after-conditions -> ?aftercondition]
            Not(?aftercondition["transferred-after-condition"^^rif:local -> ?andpattern])
            ?andpattern[cs:conditional-element -> ?conditions]
          ) Then Do (
            Assert(?aftercondition["transferred-after-condition"^^rif:local -> ?andpattern])
            Modify(?andpattern[cs:conditional-element -> External(func:append(?conditions ?aftercondition))])
          )
        )
      )

        (* self:rule76 *) Forall ?superformula ?subformula ?clipsvar (
          If And (
            ?superformula # rif:And
            ?superformula["add-pattern-from"^^rif:local -> ?subformula]
            ?superformula[modelA:binds-var -> ?clipsvar]
            Not( ?superformula["added-pattern-from"^^rif:local -> ?subformula] )
          ) Then Do (
            Assert( ?subformula["bound-variable"^^rif:local -> ?clipsvar] )
          )
        )

      Group (
        (* self:rule92 *) Forall ?rifatom ?arglist ?rifvar ?clipsvar (
          If And (
            ?rifatom # modelA:AtomPatternGenerator
            ?rifatom[rif:args -> ?arglist]
            ?rifvar # rif:Var
            External(pred:list-contains(?arglist ?rifvar))
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule93 *) Forall ?rifmember ?rifvar ?clipsvar (
          If And (
            ?rifmember # modelA:MemberPatternGenerator
            Or (
              ?rifmember[rif:instance -> ?rifvar]
              ?rifmember[rif:class -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule94 *) Forall ?rifsubclass ?rifvar ?clipsvar (
          If And (
            ?rifsubclass # modelA:SubclassPatternGenerator
            Or (
              ?rifsubclass[rif:sub -> ?rifvar]
              ?rifsubclass[rif:super -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule95 *) Forall ?rifframe ?rifvar ?clipsvar (
          If And (
            ?rifframe # modelA:TripleTemplateGenerator
            Or (
              ?rifframe[rif:object -> ?rifvar]
              ?rifframe[rif:slotkey -> ?rifvar]
              ?rifframe[rif:slotvalue -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
      )
      (* self:rule41 *) Forall ?formula ?formulacontainer ?clipsvar (
        If And (
          ?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer]
          ?formula[modelA:binds-var -> ?clipsvar]
        ) Then Do (
          Assert( ?formulacontainer["bound-variable"^^rif:local -> ?clipsvar] )
        )
      )

      (* self:rule42 *) Forall ?formulacontainer ?clipsvar ?formula (
        If And (
          Or (
            ?formulacontainer # rif:And
            ?formulacontainer # rif:Forall
            ?formulacontainer # rif:Implies
          )
          ?formulacontainer["bound-variable"^^rif:local -> ?clipsvar]
          ?formulacontainer["add-pattern-from"^^rif:local -> ?formula]
          Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?formula] )
        ) Then Do (
          Assert(?formula["bound-variable"^^rif:local -> ?clipsvar])
        )
      )
      (* self:rule62 *) Forall ?rifnot ?rifformula ?clipsvar (
        If And (
          Or (
            ?rifnot # rif:INeg
            ?rifnot # rif:Exists
          )
          ?rifnot[rif:formula -> ?rifformula]
          ?rifnot["bound-variable"^^rif:local -> ?clipsvar]
          Not(Exists ?subpattern (
            ?rifnot["added-pattern-from"^^rif:local -> ?subpattern]
          ))
        ) Then Do (
          Assert(?rifformula["bound-variable"^^rif:local -> ?clipsvar])
        )
      )

      (* self:rule43 *) Forall ?riflist ?unboundvar (
        If And (
          ?riflist # modelA:ListAsConstraint
          ?riflist["expression-needs-var"^^rif:local -> ?unboundvar]
          Not( ?riflist["bound-variable"^^rif:local -> ?unboundvar] )
        ) Then Do (
          Assert( ?riflist[modelA:binds-var -> ?unboundvar] )
        )
      )
      Group -10 (
        (* self:rule44 *) Forall ?riflist (
          If And (
            ?riflist # rif:List
            ?riflist # modelA:ConstraintGenerator
            Not( ?riflist # modelA:ListAsConstraint )
            Not (Exists ?rest (?riflist[rif:rest -> ?rest]))
            Not (Exists ?x ( And(
              ?riflist["expression-needs-var"^^rif:local -> ?x]
              Not( ?riflist["bound-variable"^^rif:local -> ?x] )
            )))
          ) Then Do (
            Assert( ?riflist # modelA:ExpressionGenerator )
          )
        )
        (* self:rule45 *) Forall ?riflist ?unboundvar (
          If And (
            ?riflist # rif:List
            ?riflist # modelA:ConstraintGenerator
            Not( ?riflist # modelA:ExpressionGenerator )
            ?riflist["expression-needs-var"^^rif:local -> ?unboundvar]
            Not( ?riflist["bound-variable"^^rif:local -> ?unboundvar] )
          ) Then Do (
            Assert( ?riflist # modelA:ListAsConstraint )
          )
        )
        (* self:rule46 *) Forall ?formulacontainer ?rifframe ?frameobject ?slotlist ?slot ?slotkey ?slotvalue ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifframe]
            ?rifframe[rif:object -> ?frameobject]
            ?rifframe[rif:slots -> ?slotlist]
            External(pred:is-list(?slotlist))
            ?slot[rif:slotkey -> ?slotkey]
            ?slot[rif:slotvalue -> ?slotvalue]
            External(pred:list-contains(?slotlist ?slot))
            Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot] )
            Not (Exists ?x ( And(
              ?slot["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?slot["bound-variable"^^rif:local -> ?x] )
            )))
            Not (Exists ?x ( And(
              ?frameobject["constraint-needs-variable"^^rif:local -> ?x]
              Not( ?slot["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot])
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifframe] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?slot))]
            )
            Assert(?slot # modelA:TripleTemplateGenerator)
            Assert(?slot["transfer-variable-binding"^^rif:local -> ?formulacontainer])
            Assert(?rifframe # modelA:TripleTemplateGenerator)
            Assert(?rifframe["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule60 *) Forall ?rifmember ?formulacontainer ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifmember]
            ?rifmember # rif:Member
            Not (Exists ?x ( And(
              ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?rifmember["bound-variable"^^rif:local -> ?x] )
            )))
            Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifmember))]
            )
            Assert(?rifmember # modelA:MemberPatternGenerator)
            Assert(?rifmember # modelA:PatternGenerator)
          )
        )
        (* self:rule61 *) Forall ?rifmember ?formulacontainer ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifmember]
            ?rifmember # rif:Subclass
            Not (Exists ?x ( And(
              ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?rifmember["bound-variable"^^rif:local -> ?x] )
            )))
            Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifmember))]
            )
            Assert(?rifmember # modelA:SubclassPatternGenerator)
            Assert(?rifmember # modelA:PatternGenerator)
          )
        )
        (* self:rule47 *) Forall ?formulacontainer ?rifatom ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifatom]
            ?rifatom # rif:Atom
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifatom])
            Not (Exists ?x ( And(
              ?rifatom["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?rifatom["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifatom] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifatom))]
            )
            Assert(?rifatom # modelA:AtomPatternGenerator)
            Assert(?rifatom # modelA:PatternGenerator)
          )
        )
        (* self:rule48 *) Forall ?formulacontainer ?rifexternal ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifexternal]
            ?rifexternal # rif:External
            ?rifexternal # modelA:ConditionGenerator
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal])
            Not (Exists ?x ( And(
              ?rifexternal["expressions-needs-var"^^rif:local -> ?x]
              Not( ?rifexternal["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifexternal))]
            )
            Assert(?rifexternal # modelA:TestPatternExternalGenerator)
            Assert(?rifexternal # modelA:PatternGenerator)
          )
        )
        (* self:rule49 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
            ?rifequal # modelA:ConditionGenerator
            ?rifequal # rif:Equal
            ?rifequal[rif:left -> ?rifleft]
            ?rifequal[rif:right -> ?rifright]
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
            Not (Exists ?x ( And(
              ?rifleft["expression-needs-var"^^rif:local -> ?x]
              Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
            )))
            Not (Exists ?x ( And(
              ?rifright["expression-needs-var"^^rif:local -> ?x]
              Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
            Modify(
              ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifequal))]
            )
            Assert(?rifequal # modelA:TestPatternEqualGenerator)
            Assert(?rifequal # modelA:PatternGenerator)
            Assert(?rifleft # modelA:ExpressionGenerator)
            Assert(?rifright # modelA:ExpressionGenerator)
          )
        )
        Group -12 (
        (* self:rule50 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?clipsassign ?defrule ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
            ?formulacontainer[modelA:as-defrule -> ?defrule]
            ?rifequal # rif:Equal
            ?rifequal[rif:left -> ?rifleft]
            ?rifleft # rif:Var
            ?rifleft[ex:as-constraint -> ?clipsassign]
            Not( ?rifequal["bound-variable"^^rif:local -> ?clipsassign] )
            ?rifequal[rif:right -> ?rifright]
            Not (Exists ?x ( And(
              ?rifright["expression-needs-var"^^rif:local -> ?x]
              Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?rifequal[modelA:binds-var -> ?clipsassign] )
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
            Assert(?rifequal # modelA:TestPatternLeftAssignGenerator)
            Assert(?rifequal # modelA:PatternGenerator)
            Assert(?rifright # modelA:ExpressionGenerator)

            Assert(?formulacontainer["bound-variable"^^rif:local -> ?clipsassign ])
          )
        )
        (* self:rule52 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?clipsassign ?defrule ?formulalist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
            ?formulacontainer[modelA:as-defrule -> ?defrule]
            ?rifequal # rif:Equal
            ?rifequal[rif:right -> ?rifright]
            ?rifright # rif:Var
            ?rifright[ex:as-constraint -> ?clipsassign]
            Not( ?rifequal["bound-variable"^^rif:local -> ?clipsassign] )
            ?rifequal[rif:left -> ?rifleft]
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
            Not (Exists ?x ( And(
              ?rifleft["expression-needs-var"^^rif:local -> ?x]
              Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?rifequal[modelA:binds-var -> ?clipsassign] )
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
            Assert(?rifequal # modelA:TestPatternRightAssignGenerator)
            Assert(?rifequal # modelA:PatternGenerator)
            Assert(?formulacontainer["bound-variable"^^rif:local -> ?clipsassign ])
          )
        )
        )
        (* self:rule53 *) Forall ?formulacontainer ?rifexternal ?defrule ?rifconstiristring ?rifexternal ?rifatom ?arglist ?targetiri ?clipsassign ?targetstring ?formulalist (
          If And(
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifexternal]
            ?formulacontainer[modelA:as-defrule -> ?defrule]
            Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal])
            ?rifconstiristring[rif:constIRI -> "http://www.w3.org/2007/rif-builtin-predicate#iri-string"^^xs:anyURI]
            ?rifatom[rif:op -> ?rifconstiristring]
            ?rifexternal[rif:content -> ?rifatom]
            ?rifexternal # rif:External
            ?rifatom[rif:args -> ?arglist]
            External(pred:is-list(?arglist))

            ?targetiri # rif:Var
            ?targetiri = External(func:get(?arglist 0))
            ?targetstring[ex:as-expression -> ?clipsassign]
            ?targetstring = External(func:get(?arglist 1))
            Not( ?rifexternal["bound-variable"^^rif:local -> ?clipsassign] )
            Not (Exists ?x ( And(
              ?targetstring["expression-needs-var"^^rif:local -> ?x]
              Not( ?rifexternal["bound-variable"^^rif:local -> ?x] )
            )))
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert(?rifexternal # modelA:AssignGenerator)
            Assert(?targetiri["use-expression-from"^^rif:local -> ?targetstring])
            Assert(?targetstring # modelA:ExpressionGenerator)
            Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal] )
            Assert(?formulacontainer["bound-variable"^^rif:local -> ?targetstring])
          )
        )

        (* self:rule96 *) Forall ?superpattern ?subpattern ?formulalist (
          If And (
            ?superpattern["add-pattern-from"^^rif:local -> ?subpattern]
            Or (
              ?subpattern # rif:INeg
              ?subpattern # rif:Exists
            )
            Not(?superpattern["added-pattern-from"^^rif:local -> ?subpattern])
            Not (Exists ?x ( And(
              ?subpattern["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?superpattern["bound-variable"^^rif:local -> ?x] )
            )))
            Not (Exists ?subsub ( And(
              ?subpattern["add-pattern-from"^^rif:local -> ?subsub]
              Not( ?subpattern["added-pattern-from"^^rif:local -> ?subsub] )
            )))
            ?superpattern["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?superpattern["added-pattern-from"^^rif:local -> ?subpattern] )
            Modify(
              ?superpattern["formulalist"^^rif:local -> External(func:append(?formulalist ?subpattern))]
            )
          )
        )
        (* self:rule54 *) Forall ?superpattern ?subpattern ?formulalist (
          If And (
            ?superpattern["add-pattern-from"^^rif:local -> ?subpattern]
            Or (
              ?subpattern # rif:And
              ?subpattern # rif:Implies
              ?subpattern # rif:Or
            )
            Not(?superpattern["added-pattern-from"^^rif:local -> ?subpattern])
            Not (Exists ?x ( And(
              ?subpattern["constraints-needs-variable"^^rif:local -> ?x]
              Not( ?subpattern["bound-variable"^^rif:local -> ?x] )
            )))
            Not (Exists ?subsub ( And(
              ?subpattern["add-pattern-from"^^rif:local -> ?subsub]
              Not( ?subpattern["added-pattern-from"^^rif:local -> ?subsub] )
            )))
            ?superpattern["formulalist"^^rif:local -> ?formulalist]
          ) Then Do (
            Assert( ?superpattern["added-pattern-from"^^rif:local -> ?subpattern] )
            Modify(
              ?superpattern["formulalist"^^rif:local -> External(func:append(?formulalist ?subpattern))]
            )
          )
        )

      )

      (* self:rule55 *) Forall ?rifrule ?rifaction (
        If Or (
          ?rifrule[rif:then -> ?rifaction]
          And (
            ?rifrule # rif:Forall
            ?rifrule[rif:formula -> ?rifaction]
          )
        ) Then Do (
          Assert(?rifrule["add-as-action"^^rif:local -> ?rifaction])
        )
      )
      (* self:rule56 *) Forall ?super ?sub ?rifaction (
        If And (
          ?super["add-as-action"^^rif:local -> ?sub]
          ?sub["add-as-action"^^rif:local -> ?rifaction]
        ) Then Do (
          Assert(?super["add-as-action"^^rif:local -> ?rifaction])
        )
      )
      (* self:rule57 *) Forall ?rifrule ?rifaction (
        If And (
          ?rifrule["add-as-action"^^rif:local -> ?rifaction]
          Not(?rifaction # rif:Forall)
          Not(?rifaction # rif:Implies)
        ) Then Do (
          Assert(?rifaction # modelA:ActionGenerator)
        )
      )
      (* self:rule58 *) Forall ?rifrule ?defrule ?rifaction ?clipsaction (
        If And (
          ?rifrule[modelA:as-defrule -> ?defrule]
          ?rifrule["add-as-action"^^rif:local -> ?rifaction]
          Or (
            ?rifaction[modelA:as-action -> ?clipsaction]
            ?rifaction[ex:as-action -> ?clipsaction]
          )
        ) Then Do (
          Assert(?defrule[cs:action -> ?clipsaction])
        )
      )
      (* self:rule59 *) Forall ?rifvar ?rifexpression ?clipsvar ?clipsexpression (
        If And (
          ?rifvar["use-expression-from"^^rif:local -> ?rifexpression]
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsvar]
          ?rifexpression[ex:as-expression -> ?clipsexpression]
        ) Then Do (
          Assert( ?clipsvar[cs:var-as-const-expr -> ?clipsexpression] )
        )
      )
    )
)
