Document(
    Prefix(func <http://www.w3.org/2007/rif-builtin-function#>) 
    Prefix(pred <http://www.w3.org/2007/rif-builtin-predicate#>) 
    Prefix(owl <http://www.w3.org/2002/07/owl#>)
    Prefix(deffact <http://white.gobo/crifi/resource-manager/deffacts#>)
    Prefix(rema <http://white.gobo/crifi/resource-manager#>)
    Prefix(cs <http://clips.script/>)
    Prefix(crifi <http://white.gobo/>)
    Prefix(modelA <http://white.gobo/modelA#>)
    Prefix(triplestordf <http://example.com/triples-to-rdf#>)
    Prefix(rif <http://www.w3.org/2007/rif#>)
    Prefix(entailment <http://www.w3.org/ns/entailment/>)
    Prefix(ex <http://example.com/>)
    Prefix(exa <http://example.com/a#>)
    Prefix(self <http://example.com/variable-binding#>)
    Group 5 (
      Group -100 (
        (* self:rule75 *) Forall ?rif ?pattern (
          If And (
            ?rif["add-pattern-from"^^rif:local -> ?pattern]
            Not( ?rif["added-pattern-from"^^rif:local -> ?pattern] )
          ) Then Do (
            Assert(?pattern # ex:misses-bound-variables)
            Assert(?rif[ex:misses-pattern-for -> ?pattern])
            Execute(crifi:set-graph-in-errorstate("Dont know where to add pattern for a formula(ex:misses-bound-variables)"))
          )
        )
        (* self:rule63 *) Forall ?formulacontainer ?formulalist (
          If And (
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            External(pred:numeric-greater-than(External(func:count(?formulalist)) 0))
          ) Then Do (
            Assert(External(func:get(?formulalist 0)) # ex:couldnt-translate-to-pattern)
            Assert(?formulacontainer # ex:missing-translated-pattern)
            Execute(crifi:set-graph-in-errorstate("Couldnt translate formula to pattern.(ex:couldnt-translate-to-pattern ex:missing-translated-pattern)"))
          )
        )
      )
      Group (
        (* self:rule64 *) Forall ?formula (
          If Or (
            ?formula # rif:And
            ?formula # rif:Or
            ?formula # rif:Exists
            ?formula # rif:External
            ?formula # rif:INeg
            ?formula # rif:Frame
            ?formula # rif:Atom
            ?formula # rif:Member
            ?formula # rif:SubClass
            ?formula # rif:Equal
          ) Then Do( Assert(?formula # "rifformula"^^rif:local) )
        )
        (* self:rule65 *) Forall ?rifvar ?clipsconstraint (
          If And (
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsconstraint]
          ) Then ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
        )
        (* self:rule66 *) Forall ?riflist ?itemlist ?rifvar ?clipsconstraint (
          If And (
            ?riflist # ex:ConstraintGenerator
            ?riflist[rif:items -> ?itemlist]
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            External(pred:list-contains(?itemlist ?rifvar))
          ) Then ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
        )
        (* self:rule67 *) Forall ?rifrule ?rifformula ?clipsconstraint (
          If And (
            ?rifrule[rif:formula -> ?rifformula]
            Or (
              ?rifformula # rif:Frame
              ?rifformula # rif:Atom
              ?rifformula # rif:External
              ?rifformula # rif:Equal
              ?rifformula # rif:Member
            )
            ?rifformula["bound-variable"^^rif:local -> ?clipsconstraint]
          ) Then Do (
            Assert( ?rifformula[modelA:bound-variable -> ?clipsconstraint] )
          )
        )
        (* self:rule68 *) Forall ?rifrule ?formulalist ?rifformula ?clipsconstraint (
          If And (
            ?rifrule # rif:And
            ?rifrule[rif:formulas -> ?formulalist]
            Or (
              ?rifformula # rif:Frame
              ?rifformula # rif:Atom
              ?rifformula # rif:External
              ?rifformula # rif:Equal
              ?rifformula # rif:Member
            )
            External(pred:list-contains(?formulalist ?rifformula))
            ?rifformula["bound-variable"^^rif:local -> ?clipsconstraint]
          ) Then Do (
            Assert( ?rifformula[modelA:bound-variable -> ?clipsconstraint] )
          )
        )
        (* self:rule69 *) Forall ?rifobj ?rifvar ?clipsconstraint (
          If And (
            Or (
              ?rifobj # modelA:TripleTemplateGenerator
              ?rifobj # modelA:MemberPatternGenerator
              ?rifobj # modelA:SubclassPatternGenerator
            )
            Or (
              ?rifobj[rif:object -> ?rifvar]
              ?rifobj[rif:slotkey -> ?rifvar]
              ?rifobj[rif:slotvalue -> ?rifvar]
              ?rifobj[rif:sub -> ?rifvar]
              ?rifobj[rif:super -> ?rifvar]
              ?rifobj[rif:class -> ?rifvar]
              ?rifobj[rif:instance -> ?rifvar]
            )
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            Not(?rifobj["bound-variable"^^rif:local -> ?clipsconstraint])
          ) Then ?rifobj[modelA:binds-var -> ?clipsconstraint]
        )
        (* self:rule70 *) Forall ?rifobj ?rifvar ?clipsconstraint (
          If And (
            ?rifobj # modelA:AtomPatternGenerator
            ?rifobj[rif:op -> ?rifvar]
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            Not(?rifobj["bound-variable"^^rif:local -> ?clipsconstraint])
          ) Then ?rifobj[modelA:binds-var -> ?clipsconstraint]
        )
        (* self:rule71 *) Forall ?rifformula ?clipsconstraint ?rifvar (
          If And (
            ?rifformula # modelA:PatternGenerator
            Or (
              ?rifformula[rif:left -> ?rifvar]
              ?rifformula[rif:right -> ?rifvar]
              ?rifformula[rif:op -> ?rifvar]
              ?rifformula[rif:instance -> ?rifvar]
              ?rifformula[rif:class -> ?rifvar]
              ?rifformula[rif:sub -> ?rifvar]
              ?rifformula[rif:super -> ?rifvar]
            )
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            Not(?rifformula["bound-variable"^^rif:local -> ?clipsconstraint])
          ) Then ?rifformula[modelA:binds-var -> ?clipsconstraint]
        )
        (* self:rule72 *) Forall ?riflist ?rifvar ?clipsconstraint (
          If And (
            ?riflist[rif:rest -> ?rifvar]
            ?riflist # modelA:ConstraintGenerator
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
          ) Then Do (
            Assert( ?riflist["constraint-binds-var"^^rif:local -> ?clipsconstraint] )
          )
        )
        (* self:rule73 *) Forall ?riflist ?itemlist ?rifvar ?clipsconstraint (
          If And (
            ?riflist[rif:items -> ?itemlist]
            ?riflist # modelA:ConstraintGenerator
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            External(pred:list-contains(?itemlist ?rifvar))
          ) Then Do (
            Assert( ?riflist["constraint-binds-var"^^rif:local -> ?clipsconstraint] )
          )
        )
        (* self:rule74 *) Forall ?rifformula ?clipsvar ?rifvar (
          If And (
            Or (
              ?rifformula[rif:object -> ?rifvar]
              ?rifformula[rif:left -> ?rifvar]
              ?rifformula[rif:right -> ?rifvar]
              ?rifformula[rif:op -> ?rifvar]
              ?rifformula[rif:content -> ?rifvar]
              ?rifformula[rif:instance -> ?rifvar]
              ?rifformula[rif:class -> ?rifvar]
              ?rifformula[rif:sub -> ?rifvar]
              ?rifformula[rif:super -> ?rifvar]
              ?rifformula[rif:slotkey -> ?rifvar]
              ?rifformula[rif:slotvalue -> ?rifvar]
            )
            ?rifvar["constraint-needs-var"^^rif:local -> ?clipsvar]
          ) Then ?rifformula["constraints-needs-variable"^^rif:local -> ?clipsvar]
        )
        (* self:rule10 *) Forall ?rifexternal ?rifatom ?arglist ?arg ?clipsvar (
          If And (
            ?rifexternal # rif:External
            ?rifexternal # modelA:PatternGenerator
            ?rifexternal[rif:content -> ?rifatom]
            ?rifatom[rif:args -> ?arglist]
            ?arg # rif:Var
            ?arg[ex:as-expression -> ?clipsvar]
            External(pred:list-contains(?arglist ?arg))
          ) Then Do (
            Assert(?rifexternal["constraints-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule11 *) Forall ?rifexternal ?rifatom ?arglist ?arg ?clipsvar (
          If And (
            ?rifexternal # rif:External
            ?rifexternal # modelA:PatternGenerator
            ?rifexternal[rif:content -> ?rifatom]
            ?rifatom[rif:args -> ?arglist]
            Or (
              ?arg # rif:External
              ?arg # rif:List
            )
            ?arg["expression-needs-var"^^rif:local -> ?clipsvar]
          ) Then Do (
            Assert(?rifexternal["constraints-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule13 *) Forall ?rifatom ?arglist ?rifvar ?clipsvar (
          If And (
            ?rifatom[rif:args -> ?arglist]
            ?rifvar["constraint-needs-var"^^rif:local -> ?clipsvar]
            External(pred:list-contains(?arglist ?rifvar))
          ) Then ?rifatom["constraints-needs-variable"^^rif:local -> ?clipsvar]
        )
        (* self:rule14 *) Forall ?rifframe ?clipsconstraint ?slotlist ?rifvar ?slot (
          If And (
            ?rifframe[rif:slots -> ?slotlist]
            ?rifframe # modelA:PatternGenerator
            ?slot # rif:Slot
            External(pred:list-contains(?slotlist ?slot))
            Or (
              ?slot[rif:slotkey -> ?rifvar]
              ?slot[rif:slotvalue -> ?rifvar]
            )
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            Not(?rifframe["bound-variable"^^rif:local -> ?clipsconstraint])
          ) Then ?rifframe[modelA:binds-var -> ?clipsconstraint]
        )
        (* self:rule15 *) Forall ?rifatom ?clipsconstraint ?arglist ?rifvar (
          If And (
            ?rifatom # modelA:PatternGenerator
            ?rifatom[rif:args -> ?arglist]
            ?rifvar["constraint-binds-var"^^rif:local -> ?clipsconstraint]
            External(pred:list-contains(?arglist ?rifvar))
            Not(?rifatom["bound-variable"^^rif:local -> ?clipsconstraint])
          ) Then ?rifatom[modelA:binds-var -> ?clipsconstraint]
        )

        (* self:rule16 *) Forall ?rifor ?formulalist ?firstsubformula ?clipsconstraint (
          If And (
            ?rifor # rif:Or
            ?rifor[rif:formulas -> ?formulalist]
            ?firstsubformula[modelA:binds-var -> ?clipsconstraint]
            ?firstsubformula = External(func:get(?formulalist 0))
            Not( Exists ?otherformula ( And(
              ?otherformula # "rifformula"^^rif:local
              External(pred:list-contains(?formulalist ?otherformula))
              Not (?otherformula[modelA:binds-var -> ?clipsconstraint])
            )))
          ) Then ?rifor[modelA:binds-var -> ?clipsconstraint]
        )
        (* self:rule17 *) Forall ?rifand ?formulalist ?subformula ?clipsconstraint (
          If And (
            ?rifand # rif:And
            ?rifand[rif:formulas -> ?formulalist]
            ?rifand["added-pattern-from"^^rif:local -> ?subformula]
            ?subformula[modelA:binds-var -> ?clipsconstraint]
            External(pred:list-contains(?formulalist ?subformula))
          ) Then ?rifand[modelA:binds-var -> ?clipsconstraint]
        )

        Forall ?rifequal ?left ?right (
          If And (
            ?rifequal # modelA:ConditionGenerator
            ?rifequal[rif:left -> ?left]
            ?rifequal[rif:right -> ?right]
          ) Then Do (
            Assert( ?left # "check-expression-needs-var"^^rif:local )
            Assert( ?right # "check-expression-needs-var"^^rif:local )
          )
        )
        Forall ?formulacontainer ?rifatom ?rifexternal ?arglist (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifatom]
            ?rifatom[rif:args -> ?arglist]
            ?rifexternal # rif:External
            External(pred:list-contains(?arglist ?rifexternal))
          ) Then Do (
            Assert(?rifexternal # "check-constraint-needs-var"^^rif:local)
          )
        )
        Forall ?formulacontainer ?rifpattern ?rifexternal (
          If And (
            ?formulacontainer["add-pattern-from"^^rif:local -> ?rifpattern]
            Or (
              ?rifpattern[rif:sub -> ?rifexternal]
              ?rifpattern[rif:super -> ?rifexternal]
              ?rifpattern[rif:class -> ?rifexternal]
              ?rifpattern[rif:instance -> ?rifexternal]
              ?rifpattern[rif:object -> ?rifexternal]
              ?rifpattern[rif:slotkey -> ?rifexternal]
              ?rifpattern[rif:slotvalue -> ?rifexternal]
            )
            ?rifexternal # rif:External
          ) Then Do (
            Assert(?rifexternal # "check-constraint-needs-var"^^rif:local)
          )
        )
        Forall ?rifexternal ?rifatom ?rifconstiristring ?rifatom ?arglist ?targetiri ?targetstring (
          If And (
            ?rifexternal[rif:content -> ?rifatom]
            ?rifconstiristring[rif:constIRI -> "http://www.w3.org/2007/rif-builtin-predicate#iri-string"^^xs:anyURI]
            ?rifatom[rif:op -> ?rifconstiristring]
            ?rifatom[rif:args -> ?arglist]
            Or (
              ?targetiri # rif:Var
              ?targetiri # rif:External
            )
            ?targetiri = External(func:get(?arglist 0))
            Or (
              ?targetstring # rif:Var
              ?targetstring # rif:External
            )
            ?targetstring = External(func:get(?arglist 1))
          ) Then Do (
            Assert( ?targetiri # "check-expression-needs-var"^^rif:local )
            Assert( ?targetstring # "check-expression-needs-var"^^rif:local )
          )
        )
        Forall ?rifterm ?rifvar ?clipsvar(
          If And (
            ?rifterm # "check-constraint-needs-var"^^rif:local
            ?rifterm[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
          ) Then Do (
            Assert( ?rifterm["constraint-needs-var"^^rif:local -> ?clipsvar] )
          )
        )
        Forall ?rifterm ?rifvar ?clipsvar(
          If And (
            ?rifterm # "check-expression-needs-var"^^rif:local
            ?rifterm[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
          ) Then Do (
            Assert( ?rifterm["expression-needs-var"^^rif:local -> ?clipsvar] )
          )
        )
        Forall ?rifterm ?clipsvar(
          If And (
            ?rifterm # "check-expression-needs-var"^^rif:local
            ?rifterm # rif:Var
            ?rifterm[ex:as-expression -> ?clipsvar]
          ) Then Do (
            Assert( ?rifterm["expression-needs-var"^^rif:local -> ?clipsvar] )
          )
        )

        (* self:rule27 *) Forall ?group ?sentences ?rifrule (
          If And (
            ?group[rif:sentences -> ?sentences]
            Or (
              ?rifrule # rif:Implies
              ?rifrule # rif:Forall
            )
            External(pred:is-list(?sentences))
            External(pred:list-contains(?sentences ?rifrule))
          ) Then Do(
            (?defrule New())
            Assert(?rifrule["formulalist"^^rif:local -> List()])

            Assert(?rifrule[modelA:as-defrule -> ?defrule])
            Assert(?defrule # cs:Defrule)
            Assert(?defrule[cs:conditional-element -> List()])
          )
        )
        (* self:rule28 *) Forall ?formula (
          If And (
            ?formula # rif:Or
          ) Then Do(
            (?clipsor New())
            Assert(?formula["formulalist"^^rif:local -> List()])

            Assert(?formula[modelA:as-lhs-pattern -> ?clipsor])
            Assert(?clipsor # cs:OrCE)
            Assert(?clipsor[cs:conditional-element -> List()])
          )
        )
        (* self:rule29 *) Forall ?formula (
          If And (
            ?formula # rif:INeg
          ) Then Do(
            (?clipsnot New())
            Assert(?formula["formulalist"^^rif:local -> List()])
            Assert(?formula[modelA:as-lhs-pattern -> ?clipsnot])
            Assert(?clipsnot # cs:NotCE)
            Assert(?clipsnot[cs:conditional-element -> List()])
          )
        )
      )
      Group 11 (
        (* self:rule80 *) Forall ?rifineg ?clipsvar ?rifvarconsumer (
          If And (
            ?rifineg # rif:INeg
            ?rifineg[ex:inherits-data -> ?rifvarconsumer]
            ?rifvarconsumer[ex:as-expression -> ?clipsvar]
          ) Then Do (
            Assert(?rifineg["subpattern-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule81 *) Forall ?formula ?varlist ?rifvar ?clipsvar (
          If And (
            ?formula # rif:Exists
            ?formula[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
            ?formula[rif:vars -> ?varlist]
          ) Then Do (
            Assert(?formula["subpattern-needs-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule36 *) Forall ?pattern ?term ?clipsvar (
          If And (
            "always-false"^^rif:local()
            ?pattern # modelA:PatternGenerator
            ?pattern # rif:External
            ?pattern[ex:inherits-data -> ?term]
            ?term # rif:Var
            ?term[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?term["expression-needs-var"^^rif:local -> ?clipsvar] )
          )
        )
        (* self:rule12 *) Forall ?rifexternal ?rifvar ?clipsvar (
          If And (
            ?rifexternal # rif:External
            ?rifexternal # modelA:ConditionGenerator
            ?rifexternal[ex:inherits-data -> ?rifvar]
            ?rifvar # rif:Var
            ?rifvar[ex:as-expression -> ?clipsvar]
          ) Then ?rifexternal["expressions-needs-var"^^rif:local -> ?clipsvar]
        )
      )
      Group (
        (* self:rule30 *) Forall ?formula (
          If And (
            ?formula # rif:Exists
          ) Then Do(
            (?clipsexists New())
            Assert(?formula["formulalist"^^rif:local -> List()])

            Assert(?formula[modelA:as-lhs-pattern -> ?clipsexists])
            Assert(?clipsexists # cs:ExistsCE)
            Assert(?clipsexists[cs:conditional-element -> List()])
          )
        )
        (* self:rule31 *) Forall ?rifand (
          If And (
            ?rifand # rif:And
            Not (Exists ?superand ?formulalist( And (
              ?superand[rif:formulas -> ?formulalist]
              ?superand # rif:And
              External(pred:list-contains(?formulalist ?rifand))
            )))
            Not (Exists ?superimply (
              ?superimply[rif:if -> ?rifand]
            ))
            Not ( Exists ?superrule (
              ?superrule[rif:pattern -> ?rifand]
            ))
          ) Then Do(
            (?clipsand New())
            Assert(?rifand["formulalist"^^rif:local -> List()])

            Assert(?rifand[modelA:as-lhs-pattern -> ?clipsand])
            Assert(?clipsand # cs:AndCE)
            Assert(?clipsand[cs:conditional-element -> List()])
          )
        )

        (* self:rule32 *) Forall ?formula ?rifand ?formulalist(
          If And (
            Or (
              ?formula # rif:And
              ?formula # rif:Or
              ?formula # rif:Exists
              ?formula # rif:External
              ?formula # rif:INeg
              ?formula # rif:Frame
              ?formula # rif:Atom
              ?formula # rif:Member
              ?formula # rif:SubClass
              ?formula # rif:Equal
            )
            Or (
              ?rifand # rif:And
              ?rifand # rif:Or
            )
            ?rifand[rif:formulas -> ?formulalist]
            Exists ?x(?rifand["formulalist"^^rif:local -> ?x])
            External(pred:list-contains(?formulalist ?formula))
          ) Then Do (
            Assert( ?rifand["add-pattern-from"^^rif:local -> ?formula] )
          )
        )
        (* self:rule33 *) Forall ?rifobj ?formula (
          If And(
            Or (
              ?rifobj[rif:if -> ?formula]
              ?rifobj[rif:pattern -> ?formula]
              ?rifobj[rif:formula -> ?formula]
            )
            Exists ?x(?rifobj["formulalist"^^rif:local -> ?x])
          ) Then Do (
            Assert( ?rifobj["add-pattern-from"^^rif:local -> ?formula] )
          )
        )
      )
      Group 20 (
        (* self:rule34 *) Forall ?rifand ?otherrifand ?rifformula (
          If And (
            ?rifand["add-pattern-from"^^rif:local -> ?otherrifand]
            Or (
              ?rifand # rif:And
              ?rifand # rif:Not
              ?rifand # rif:Forall
              ?rifand # rif:Implies
            )
            ?otherrifand # rif:And
            ?rifformula # modelA:ConditionGenerator
            ?otherrifand[rif:formulas -> ?formulalist]
            External(pred:list-contains(?formulalist ?rifformula))
          ) Then Do (
            Assert( ?otherrifand["added-pattern-from"^^rif:local -> ?rifformula] )
            Assert( ?rifand["added-pattern-from"^^rif:local -> ?otherrifand] )
            Assert( ?rifand["add-pattern-from"^^rif:local -> ?rifformula] )
          )
        )
        (* self:rule35 *) Forall ?rifforall ?rifrule ?rifformula (
          If And (
            ?rifforall["add-pattern-from"^^rif:local -> ?rifrule]
            Or (
              ?rifforall # rif:Forall
              ?rifforall # rif:Implies
            )
            Or (
              ?rifrule # rif:Forall
              ?rifrule # rif:Implies
            )
            Or (
              ?rifrule[rif:formula -> ?rifformula]
              ?rifrule[rif:if -> ?rifformula]
            )
          ) Then Do (
            Assert( ?rifrule["added-pattern-from"^^rif:local -> ?rifformula] )
            Assert( ?rifforall["added-pattern-from"^^rif:local -> ?rifrule] )
            Assert( ?rifforall["add-pattern-from"^^rif:local -> ?rifformula] )
          )
        )
      )

      Group -1 (
        (* self:rule91 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ?formula # modelA:MultiPatternGenerator
            ?formula[modelA:as-multi-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
          ) Then Do (
            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?subpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule38 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            Not(?formula # modelA:MultiPatternGenerator)
            ?formula[modelA:as-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
            Not (Exists ?aftercondition (?formula[modelA:lhs-pattern-after-conditions -> ?aftercondition]))
          ) Then Do (
            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?subpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule39 *) Forall ?superpattern ?formulacontainer ?formulalist ?subpattern ?formula ?patternlist (
          If And (
            Or (
              ?superpattern # cs:AndCE
              ?superpattern # cs:OrCE
              ?superpattern # cs:NotCE
              ?superpattern # cs:ExistsCE
              ?superpattern # cs:Defrule
            )
            Or (
              ?formulacontainer[modelA:as-defrule -> ?superpattern]
              ?formulacontainer[modelA:as-lhs-pattern -> ?superpattern]
            )
            ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ?formula[modelA:as-lhs-pattern -> ?subpattern]
            ?formula = External(func:get(?formulalist 0))
            ?superpattern[cs:conditional-element -> ?patternlist]
            Exists ?x ( ?formula[modelA:lhs-pattern-after-conditions -> ?x] )
          ) Then Do (
            (?andpattern New())
            Assert( ?andpattern # cs:AndCE )
            Assert( ?andpattern[cs:conditional-element -> List(?subpattern)])
            Assert( ?formula["transfer-after-conditions"^^rif:local -> ?andpattern])

            Modify(?formulacontainer["formulalist"^^rif:local -> External(func:remove(?formulalist 0))])
            Modify(?superpattern[cs:conditional-element -> External(func:append(?patternlist ?andpattern))])
            Assert(?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer])
          )
        )
        (* self:rule40 *) Forall ?formula ?andpattern ?aftercondition ?conditions (
          If And (
            ?formula["transfer-after-conditions"^^rif:local -> ?andpattern]
            ?formula[modelA:lhs-pattern-after-conditions -> ?aftercondition]
            Not(?aftercondition["transferred-after-condition"^^rif:local -> ?andpattern])
            ?andpattern[cs:conditional-element -> ?conditions]
          ) Then Do (
            Assert(?aftercondition["transferred-after-condition"^^rif:local -> ?andpattern])
            Modify(?andpattern[cs:conditional-element -> External(func:append(?conditions ?aftercondition))])
          )
        )
      )

      Group (
        (* self:rule76 *) Forall ?superformula ?subformula ?clipsvar (
          If And (
            ?superformula # rif:And
            ?superformula["add-pattern-from"^^rif:local -> ?subformula]
            ?superformula[modelA:binds-var -> ?clipsvar]
            Not( ?superformula["added-pattern-from"^^rif:local -> ?subformula] )
          ) Then Do (
            Assert( ?subformula["bound-variable"^^rif:local -> ?clipsvar] )
          )
        )
        (* self:rule41 *) Forall ?formula ?formulacontainer ?clipsvar (
          If And (
            ?formula["transfer-variable-binding"^^rif:local -> ?formulacontainer]
            ?formula[modelA:binds-var -> ?clipsvar]
          ) Then Do (
            Assert( ?formulacontainer["bound-variable"^^rif:local -> ?clipsvar] )
          )
        )

        (* self:rule42 *) Forall ?formulacontainer ?clipsvar ?formula (
          If And (
            Or (
              ?formulacontainer # rif:And
              ?formulacontainer # rif:Forall
              ?formulacontainer # rif:Implies
            )
            ?formulacontainer["bound-variable"^^rif:local -> ?clipsvar]
            ?formulacontainer["add-pattern-from"^^rif:local -> ?formula]
            Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?formula] )
          ) Then Do (
            Assert(?formula["bound-variable"^^rif:local -> ?clipsvar])
          )
        )
        (* self:rule62 *) Forall ?rifnot ?rifformula ?clipsvar (
          If And (
            Or (
              ?rifnot # rif:INeg
              ?rifnot # rif:Exists
            )
            ?rifnot[rif:formula -> ?rifformula]
            ?rifnot["bound-variable"^^rif:local -> ?clipsvar]
            Not(Exists ?subpattern (
              ?rifnot["added-pattern-from"^^rif:local -> ?subpattern]
            ))
          ) Then Do (
            Assert(?rifformula["bound-variable"^^rif:local -> ?clipsvar])
          )
        )

        (* self:rule43 *) Forall ?riflist ?unboundvar (
          If And (
            ?riflist # modelA:ListAsConstraint
            ?riflist["expression-needs-var"^^rif:local -> ?unboundvar]
            Not( ?riflist["bound-variable"^^rif:local -> ?unboundvar] )
          ) Then Do (
            Assert( ?riflist[modelA:binds-var -> ?unboundvar] )
          )
        )
      )

      Group (
        (* self:rule92 *) Forall ?rifatom ?arglist ?rifvar ?clipsvar (
          If And (
            ?rifatom # modelA:AtomPatternGenerator
            ?rifatom[rif:args -> ?arglist]
            ?rifvar # rif:Var
            External(pred:list-contains(?arglist ?rifvar))
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule93 *) Forall ?rifmember ?rifvar ?clipsvar (
          If And (
            ?rifmember # modelA:MemberPatternGenerator
            Or (
              ?rifmember[rif:instance -> ?rifvar]
              ?rifmember[rif:class -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule94 *) Forall ?rifsubclass ?rifvar ?clipsvar (
          If And (
            ?rifsubclass # modelA:SubclassPatternGenerator
            Or (
              ?rifsubclass[rif:sub -> ?rifvar]
              ?rifsubclass[rif:super -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
        (* self:rule95 *) Forall ?rifframe ?rifvar ?clipsvar (
          If And (
            ?rifframe # modelA:TripleTemplateGenerator
            Or (
              ?rifframe[rif:object -> ?rifvar]
              ?rifframe[rif:slotkey -> ?rifvar]
              ?rifframe[rif:slotvalue -> ?rifvar]
            )
            ?rifvar # rif:Var
            ?rifvar[ex:as-constraint -> ?clipsvar]
          ) Then Do (
            Assert( ?clipsvar # ex:Variable )
          )
        )
      )
      Group -10 (
        (* self:rule44 *) Forall ?riflist (
          If And (
            ?riflist # rif:List
            ?riflist # modelA:ConstraintGenerator
            Not( ?riflist # modelA:ListAsConstraint )
            Not (Exists ?rest (?riflist[rif:rest -> ?rest]))
            Not (Exists ?x ( And(
              ?riflist["expression-needs-var"^^rif:local -> ?x]
              Not( ?riflist["bound-variable"^^rif:local -> ?x] )
            )))
          ) Then Do (
            Assert( ?riflist # modelA:ExpressionGenerator )
          )
        )
        (* self:rule45 *) Forall ?riflist ?unboundvar (
          If And (
            ?riflist # rif:List
            ?riflist # modelA:ConstraintGenerator
            Not( ?riflist # modelA:ExpressionGenerator )
            ?riflist["expression-needs-var"^^rif:local -> ?unboundvar]
            Not( ?riflist["bound-variable"^^rif:local -> ?unboundvar] )
          ) Then Do (
            Assert( ?riflist # modelA:ListAsConstraint )
          )
        )
      )
      Group -10 (
        Group -7 (
          (* self:rule48 *) Forall ?formulacontainer ?rifexternal ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifexternal]
              ?rifexternal # rif:External
              ?rifexternal # modelA:ConditionGenerator
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal])
              Not (Exists ?x ( And(
                ?rifexternal["expressions-needs-var"^^rif:local -> ?x]
                Not( ?rifexternal["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifexternal))]
              )
              Assert(?rifexternal # modelA:TestPatternExternalGenerator)
              Assert(?rifexternal # modelA:PatternGenerator)
            )
          )
          (* self:rule49 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
              ?rifequal # modelA:ConditionGenerator
              ?rifequal # rif:Equal
              ?rifequal[rif:left -> ?rifleft]
              ?rifequal[rif:right -> ?rifright]
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
              Not (Exists ?x ( And(
                ?rifleft["expression-needs-var"^^rif:local -> ?x]
                Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?x ( And(
                ?rifright["expression-needs-var"^^rif:local -> ?x]
                Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifequal))]
              )
              Assert(?rifequal # modelA:TestPatternEqualGenerator)
              Assert(?rifequal # modelA:PatternGenerator)
              Assert(?rifleft # modelA:ExpressionGenerator)
              Assert(?rifright # modelA:ExpressionGenerator)
            )
          )
          (* self:rule60fast *) Forall ?rifmember ?formulacontainer ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifmember]
              ?rifmember # rif:Member
              Not (Exists ?x ( And(
                ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?rifmember["bound-variable"^^rif:local -> ?x] )
              )))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
              Exists ?x ( And(
                ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
                ?rifmember["bound-variable"^^rif:local -> ?x]
              ))
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifmember))]
              )
              Assert(?rifmember # modelA:MemberPatternGenerator)
              Assert(?rifmember # modelA:PatternGenerator)
            )
          )
        )
        Group -8 (
          (* self:rule46fast *) Forall ?formulacontainer ?rifframe ?frameobject ?slotlist ?slot ?slotkey ?slotvalue ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifframe]
              ?rifframe[rif:object -> ?frameobject]
              ?rifframe[rif:slots -> ?slotlist]
              External(pred:is-list(?slotlist))
              ?slot[rif:slotkey -> ?slotkey]
              ?slot[rif:slotvalue -> ?slotvalue]
              External(pred:list-contains(?slotlist ?slot))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot] )
              Exists ?x ( And(
                Or (
                  ?slot["constraints-needs-variable"^^rif:local -> ?x]
                  ?frameobject["constraint-needs-variable"^^rif:local -> ?x]
                )
                ?slot["bound-variable"^^rif:local -> ?x]
              ))
              Not (Exists ?x ( And(
                ?slot["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?x ( And(
                ?frameobject["constraint-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot])
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifframe] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?slot))]
              )
              Assert(?slot # modelA:TripleTemplateGenerator)
              Assert(?slot["transfer-variable-binding"^^rif:local -> ?formulacontainer])
              Assert(?rifframe # modelA:TripleTemplateGenerator)
              Assert(?rifframe["transfer-variable-binding"^^rif:local -> ?formulacontainer])
            )
          )
        )
        Group -9 (
          (* self:rule46localfast *) Forall ?formulacontainer ?rifframe ?frameobject ?slotlist ?slot ?slotkey ?slotvalue ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifframe]
              ?rifframe[rif:object -> ?frameobject]
              ?rifframe[rif:slots -> ?slotlist]
              External(pred:is-list(?slotlist))
              ?slot[rif:slotkey -> ?slotkey]
              Exists ?x (?slotkey[rif:constname -> ?x])
              ?slot[rif:slotvalue -> ?slotvalue]
              External(pred:list-contains(?slotlist ?slot))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot] )
              Not (Exists ?x ( And(
                ?slot["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?x ( And(
                ?frameobject["constraint-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot])
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifframe] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?slot))]
              )
              Assert(?slot # modelA:TripleTemplateGenerator)
              Assert(?slot["transfer-variable-binding"^^rif:local -> ?formulacontainer])
              Assert(?rifframe # modelA:TripleTemplateGenerator)
              Assert(?rifframe["transfer-variable-binding"^^rif:local -> ?formulacontainer])
            )
          )
        )
        Group (
          (* self:rule46 *) Forall ?formulacontainer ?rifframe ?frameobject ?slotlist ?slot ?slotkey ?slotvalue ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifframe]
              ?rifframe[rif:object -> ?frameobject]
              ?rifframe[rif:slots -> ?slotlist]
              External(pred:is-list(?slotlist))
              ?slot[rif:slotkey -> ?slotkey]
              ?slot[rif:slotvalue -> ?slotvalue]
              External(pred:list-contains(?slotlist ?slot))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot] )
              Not (Exists ?x ( And(
                ?slot["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?x ( And(
                ?frameobject["constraint-needs-variable"^^rif:local -> ?x]
                Not( ?slot["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?slot])
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifframe] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?slot))]
              )
              Assert(?slot # modelA:TripleTemplateGenerator)
              Assert(?slot["transfer-variable-binding"^^rif:local -> ?formulacontainer])
              Assert(?rifframe # modelA:TripleTemplateGenerator)
              Assert(?rifframe["transfer-variable-binding"^^rif:local -> ?formulacontainer])
            )
          )
          (* self:rule60 *) Forall ?rifmember ?formulacontainer ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifmember]
              ?rifmember # rif:Member
              Not (Exists ?x ( And(
                ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?rifmember["bound-variable"^^rif:local -> ?x] )
              )))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifmember))]
              )
              Assert(?rifmember # modelA:MemberPatternGenerator)
              Assert(?rifmember # modelA:PatternGenerator)
            )
          )
          (* self:rule61 *) Forall ?rifmember ?formulacontainer ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifmember]
              ?rifmember # rif:Subclass
              Not (Exists ?x ( And(
                ?rifmember["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?rifmember["bound-variable"^^rif:local -> ?x] )
              )))
              Not( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifmember] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifmember))]
              )
              Assert(?rifmember # modelA:SubclassPatternGenerator)
              Assert(?rifmember # modelA:PatternGenerator)
            )
          )
          (* self:rule47 *) Forall ?formulacontainer ?rifatom ?formulalist (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifatom]
              ?rifatom # rif:Atom
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifatom])
              Not (Exists ?x ( And(
                ?rifatom["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?rifatom["bound-variable"^^rif:local -> ?x] )
              )))
              ?formulacontainer["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifatom] )
              Modify(
                ?formulacontainer["formulalist"^^rif:local -> External(func:append(?formulalist ?rifatom))]
              )
              Assert(?rifatom # modelA:AtomPatternGenerator)
              Assert(?rifatom # modelA:PatternGenerator)
            )
          )
          (* self:rule53 *) Forall ?formulacontainer ?rifexternal ?defrule ?rifconstiristring ?rifexternal ?rifatom ?arglist ?targetiri ?clipsassign ?targetstring (
            If And(
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifexternal]
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal])
              ?formulacontainer[modelA:as-defrule -> ?defrule]
              ?rifexternal[rif:content -> ?rifatom]
              ?rifatom[rif:op -> ?rifconstiristring]
              ?rifconstiristring[rif:constIRI -> "http://www.w3.org/2007/rif-builtin-predicate#iri-string"^^xs:anyURI]
              ?rifexternal # rif:External
              ?rifatom[rif:args -> ?arglist]
              External(pred:is-list(?arglist))

              ?targetiri # rif:Var
              ?targetiri = External(func:get(?arglist 0))
              ?targetstring[ex:as-expression -> ?clipsassign]
              ?targetstring = External(func:get(?arglist 1))
              Not( ?rifexternal["bound-variable"^^rif:local -> ?clipsassign] )
              Not (Exists ?x ( And(
                ?targetstring["expression-needs-var"^^rif:local -> ?x]
                Not( ?rifexternal["bound-variable"^^rif:local -> ?x] )
              )))
            ) Then Do (
              Assert(?rifexternal # modelA:AssignGenerator)
              Assert(?targetiri["use-expression-from"^^rif:local -> ?targetstring])
              Assert(?targetstring # modelA:ExpressionGenerator)
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifexternal] )
              Assert(?formulacontainer["bound-variable"^^rif:local -> ?targetstring])
            )
          )
        )
        Group -12 (
          (* self:rule50 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?clipsassign ?defrule (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
              ?formulacontainer[modelA:as-defrule -> ?defrule]
              ?rifequal # rif:Equal
              ?rifequal[rif:left -> ?rifleft]
              ?rifleft # rif:Var
              ?rifleft[ex:as-constraint -> ?clipsassign]
              Not( ?rifequal["bound-variable"^^rif:local -> ?clipsassign] )
              ?rifequal[rif:right -> ?rifright]
              Not (Exists ?x ( And(
                ?rifright["expression-needs-var"^^rif:local -> ?x]
                Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
              )))
            ) Then Do (
              Assert( ?rifequal[modelA:binds-var -> ?clipsassign] )
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
              Assert(?rifequal # modelA:TestPatternLeftAssignGenerator)
              Assert(?rifequal # modelA:PatternGenerator)
              Assert(?rifright # modelA:ExpressionGenerator)

              Assert(?formulacontainer["bound-variable"^^rif:local -> ?clipsassign ])
            )
          )
          (* self:rule52 *) Forall ?rifequal ?formulacontainer ?rifleft ?rifright ?clipsassign ?defrule (
            If And (
              ?formulacontainer["add-pattern-from"^^rif:local -> ?rifequal]
              ?formulacontainer[modelA:as-defrule -> ?defrule]
              ?rifequal # rif:Equal
              ?rifequal[rif:right -> ?rifright]
              ?rifright # rif:Var
              ?rifright[ex:as-constraint -> ?clipsassign]
              Not( ?rifequal["bound-variable"^^rif:local -> ?clipsassign] )
              ?rifequal[rif:left -> ?rifleft]
              Not(?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal])
              Not (Exists ?x ( And(
                ?rifleft["expression-needs-var"^^rif:local -> ?x]
                Not( ?rifequal["bound-variable"^^rif:local -> ?x] )
              )))
            ) Then Do (
              Assert( ?rifequal[modelA:binds-var -> ?clipsassign] )
              Assert( ?formulacontainer["added-pattern-from"^^rif:local -> ?rifequal] )
              Assert(?rifequal # modelA:TestPatternRightAssignGenerator)
              Assert(?rifequal # modelA:PatternGenerator)
              Assert(?formulacontainer["bound-variable"^^rif:local -> ?clipsassign ])
            )
          )
        )

        Group (
          (* self:rule96 *) Forall ?superpattern ?subpattern ?formulalist (
            If And (
              ?superpattern["add-pattern-from"^^rif:local -> ?subpattern]
              Or (
                ?subpattern # rif:INeg
                ?subpattern # rif:Exists
              )
              Not(?superpattern["added-pattern-from"^^rif:local -> ?subpattern])
              Not (Exists ?x ( And(
                ?subpattern["subpattern-needs-variable"^^rif:local -> ?x]
                Not( ?superpattern["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?subsub ( And(
                ?subpattern["add-pattern-from"^^rif:local -> ?subsub]
                Not( ?subpattern["added-pattern-from"^^rif:local -> ?subsub] )
              )))
              ?superpattern["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?superpattern["added-pattern-from"^^rif:local -> ?subpattern] )
              Modify(
                ?superpattern["formulalist"^^rif:local -> External(func:append(?formulalist ?subpattern))]
              )
            )
          )
          (* self:rule54 *) Forall ?superpattern ?subpattern ?formulalist (
            If And (
              ?superpattern["add-pattern-from"^^rif:local -> ?subpattern]
              Or (
                ?subpattern # rif:And
                ?subpattern # rif:Implies
                ?subpattern # rif:Or
              )
              Exists ?x(?subpattern["formulalist"^^rif:local -> ?x])
              Not(?superpattern["added-pattern-from"^^rif:local -> ?subpattern])
              Not (Exists ?x ( And(
                ?subpattern["constraints-needs-variable"^^rif:local -> ?x]
                Not( ?subpattern["bound-variable"^^rif:local -> ?x] )
              )))
              Not (Exists ?subsub ( And(
                ?subpattern["add-pattern-from"^^rif:local -> ?subsub]
                Not( ?subpattern["added-pattern-from"^^rif:local -> ?subsub] )
              )))
              ?superpattern["formulalist"^^rif:local -> ?formulalist]
            ) Then Do (
              Assert( ?superpattern["added-pattern-from"^^rif:local -> ?subpattern] )
              Modify(
                ?superpattern["formulalist"^^rif:local -> External(func:append(?formulalist ?subpattern))]
              )
            )
          )
        )
      )

      (* self:rule59 *) Forall ?rifvar ?rifexpression ?clipsvar ?clipsexpression (
        If And (
          ?rifvar["use-expression-from"^^rif:local -> ?rifexpression]
          ?rifvar # rif:Var
          ?rifvar[ex:as-expression -> ?clipsvar]
          ?rifexpression[ex:as-expression -> ?clipsexpression]
        ) Then Do (
          Assert( ?clipsvar[cs:var-as-const-expr -> ?clipsexpression] )
        )
      )
    )
)
