/** \anchor graph_generation_test.cc
 * w3c rif testcases, namely ImportRejectionTests, NegativeSyntaxTests
 * and PositiveSyntaxTests.
 */

#include <stdint.h>  /* SIZE_MAX */
#include <gtest/gtest.h>

#include "ffi_constants.h"
#include "crifi_graph_models.h"
#include "crifi_raptor.h"
#include "model_support.h"

///autogenerated by cmake compile_resources
#include "testdata_w3c_as_header.h"

#define _W3C_TESTDATA_ "http://www.w3.org/2005/rules/test/repository/tc/"
#define W3C_INPUT(id) _W3C_TESTDATA_ id "/" id "-input"
#define _OWN_TESTDATA_ "http://white.gobo/crifi/owntestdata/"
#define OWN_INPUT(id) _OWN_TESTDATA_ id "/" id "-input"

typedef crifi_graph *GraphGenerator();

class TestdataSyntax {
	public:
		std::string name;
		std::string input_uri;
		unsigned long skip_c;
		bool result;
		TestdataSyntax(
				std::string Name,
				unsigned long skip_condition,
				std::string inputUri)
		{
			skip_c = skip_condition;
			input_uri = inputUri;
			name = Name;
			result = true;
		}

		TestdataSyntax(
				std::string Name,
				unsigned long skip_condition,
				std::string inputUri,
				bool myresult)
		{
			skip_c = skip_condition;
			input_uri = inputUri;
			name = Name;
			result = myresult;
		}
};

std::ostream& operator<<(std::ostream& os, const TestdataSyntax& td){
	os << td.name;
	return os;
}

class officialw3cSyntaxTestCases_Test : public testing::TestWithParam<TestdataSyntax> {
	protected:
		/**
		 * Skip when reason is not NULL.
		 */
		void SetUp() override {
			TestdataSyntax q = GetParam();
			if (q.skip_c & SC_All){
				GTEST_SKIP() << "always skip";
			}
		}
};

static auto syntaxTestdata = testing::Values(
		TestdataSyntax("assign_var1",
			SC_NoCondition,
			OWN_INPUT("assign_var1")),
		TestdataSyntax("assign_var2",
			SC_NoCondition,
			OWN_INPUT("assign_var2")),
		TestdataSyntax("Core_IRT_Multiple_Context_Error",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("Multiple_Context_Error"),
			false),
		TestdataSyntax("Core_IRT_OWL_Combination_Invalid_DL_Formula",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("OWL_Combination_Invalid_DL_Formula"),
			false),
		TestdataSyntax("Core_IRT_OWL_Combination_Invalid_DL_Import",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("OWL_Combination_Invalid_DL_Import"),
			false),
		TestdataSyntax("Core_IRT_RDF_Combination_Invalid_Constant_1",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("RDF_Combination_Invalid_Constant_1"),
			false),
		TestdataSyntax("Core_IRT_RDF_Combination_Invalid_Constant_2",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("RDF_Combination_Invalid_Constant_2"),
			false),
		TestdataSyntax("Core_IRT_RDF_Combination_Invalid_Profiles_1",
			SC_NoCondition | SC_ModelA,
			W3C_INPUT("RDF_Combination_Invalid_Profiles_1"),
			false),
		TestdataSyntax("Core_NST_Core_NonSafeness_1",
			SC_NoCondition,
			W3C_INPUT("Core_NonSafeness"),
			false),
		TestdataSyntax("Core_NST_Core_NonSafeness_2",
			SC_NoCondition,
			W3C_INPUT("Core_NonSafeness_2"),
			false),
		TestdataSyntax("Core_NST_No_free_variables",
			SC_NoCondition,
			W3C_INPUT("No_free_variables"),
			false),
		TestdataSyntax("Core_PST_Core_Safeness_1",
			SC_NoCondition,
			W3C_INPUT("Core_Safeness")),
		TestdataSyntax("Core_PST_Core_Safeness_2",
			SC_NoCondition,
			W3C_INPUT("Core_Safeness_2")),
		TestdataSyntax("Core_PST_Core_Safeness_3",
			SC_NoCondition | SC_All,
			W3C_INPUT("Core_Safeness_3"))
		);

typedef enum {
	CREATELOGIC_NOERROR = 0,
	CREATELOGIC_UNKNOWN_GRAPHERRORSTATE,
	CREATELOGIC_NOTRUN,
	CREATELOGIC_FAILED_SERIALIZATION
} CREATELOGICERROR;


static void create_logic_into_memory(FILE* tmpmem_f, TestdataSyntax testdata,
					GraphGenerator *graph_generator,
					CREATELOGICERROR* logicerror);

static void load_from_memory_to_graph(crifi_graph *graph,
					const char *source_uri);

static bool create_new_logic(crifi_graph *create_logic_graph, FILE *memory);


TEST_P(officialw3cSyntaxTestCases_Test, CreateModelWithModelA) {
	CREATELOGICERROR logicerror = CREATELOGIC_NOTRUN;
	TestdataSyntax testdata = GetParam();

	if(skip_modelA(testdata.skip_c)){
		GTEST_SKIP() << "skip on modelA";
	}

	size_t memory_size = 1000000;
	int number_rules_run;
	char tmpmem[memory_size]; //script size maximal a megabyte
	char tmpcheckmem[memory_size]; //check command size maximal a megabyte
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	tmpcheckmem[memory_size-1] = '\0';
	tmpcheckmem[0] = '\0';
	FILE *tmpmem_f, *tmpcheckmem_f;
	crifi_graph *maingraph;

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_logic_into_memory(tmpmem_f, testdata, init_graph_modelA, &logicerror);
	fclose(tmpmem_f);
	if (strlen(tmpmem) == 0){
		fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	} else {
		fprintf(stderr, "No model was created.\n");
	}
	switch(logicerror){
		case CREATELOGIC_NOERROR:
			EXPECT_NE(strlen(tmpmem), 0) << "Graph isnt in "
				"errorstate but no model was created.";
			if (!testdata.result){
				FAIL() << "Syntax accepted. Expected failure";
			}
			break;
		case CREATELOGIC_UNKNOWN_GRAPHERRORSTATE:
			if (testdata.result){
				FAIL() << "Syntax declined. Expected success";
			}
			break;
		case CREATELOGIC_NOTRUN:
			FAIL() << "Create logic didnt run.";
			break;
		case CREATELOGIC_FAILED_SERIALIZATION:
			if (!testdata.result){
				FAIL() << "Syntax accepted. Expected failure. "
					"But serialization as clips script "
					"failed.";
			} else {
				FAIL() << "Unhandled error during serialization"
					" of graphinformation as clips script.";
			}
			break;
		default:
			FAIL() << "unspecified logic error state";
	}
}

INSTANTIATE_TEST_SUITE_P(
		officialw3cTestcases_Syntax,
		officialw3cSyntaxTestCases_Test,
		syntaxTestdata);



static void create_logic_into_memory(FILE* tmpmem_f, TestdataSyntax testdata,
					GraphGenerator *graph_generator,
					CREATELOGICERROR* logicerror)
{
	int number_rules_run;
	crifi_graph *create_logic_graph = graph_generator();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt craete modelA graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n",
					testdata.input_uri.c_str());
	load_from_memory_to_graph(create_logic_graph,
					testdata.input_uri.c_str());

	number_rules_run = run_rules(create_logic_graph, 10000);
	fprintf(stderr, "information in create_logic_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during rule creation: %d\n",
					number_rules_run);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		*logicerror = CREATELOGIC_UNKNOWN_GRAPHERRORSTATE;
	} else {
		if (create_new_logic(create_logic_graph, tmpmem_f)){
			*logicerror = CREATELOGIC_NOERROR;
		} else {
			*logicerror = CREATELOGIC_FAILED_SERIALIZATION;
		}
	}
	close_graph(create_logic_graph);
	create_logic_graph = NULL;
	//FAIL() << "testfail";
}

static void load_from_memory_to_graph(crifi_graph *graph,
					const char *source_uri)
{
	bool errorstate;
	struct DynamicValue retval;
	char command[30 + strlen(_CRIFI_import_)
			+ strlen(source_uri) + strlen(_RIFENTAIL_RIF_)];
	sprintf(command, "(<%s> <%s> <%s>)",
			_CRIFI_import_, source_uri, _RIFENTAIL_RIF_);
	retval = eval(graph, command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			ASSERT_EQ(retval.val.boolean, true)
				<< "Crifi:import failed. Used:\n"
				<< command;
			break;
		default:
			FAIL() << "crifi:import return unexpected value.";
	}
	if (errorstate){
		FAIL() << "graph ended up in errorstate after import\n";
	}
}


static bool create_new_logic(crifi_graph *create_logic_graph, FILE *memory){
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_script(memory, create_logic_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			return true;
			break;
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			return false;
	}
}
