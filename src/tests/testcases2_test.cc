/** \anchor testcases2_test.cc
 * testcases like those from w3c rif testcases
 */

#include <gtest/gtest.h>

#include "ffi_constants.h"
#include "crifi_graph_models.h"

///autogenerated by cmake compile_resources
#include "testdata_w3c_as_header.h"

#define _W3C_TESTDATA_ "http://www.w3.org/2005/rules/test/repository/tc/"

class TestdataPET {
	public:
		const char* skip;
		std::string premise_uri;
		std::string conclusion_uri;
		std::string name;
		TestdataPET(
				std::string Name,
				const char* myskip,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri
				){
			if (myskip != NULL){
				skip = myskip;
			} else {
				skip = NULL;
			}
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
		}
		TestdataPET(
				std::string Name,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri
				){
			skip = NULL;
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
		}

};

std::ostream& operator<<(std::ostream& os, const TestdataPET& td){
	os << td.name;
	return os;
}

class officialw3cPETTestCases_Test : public testing::TestWithParam<TestdataPET> {
	protected:
		/**
		 * Skip when reason is not NULL.
		 */
		void SetUp() override {
			TestdataPET q = GetParam();
			if (q.skip != NULL) {
				GTEST_SKIP() << q.skip;
			}
		}
};



static auto petTestdata = testing::Values(
		TestdataPET("Core_PET_Builtin_literal-not-identical",
			NULL,
			_W3C_TESTDATA_"Builtin_literal-not-identical/",
			"Builtin_literal-not-identical-premise.ntriples",
			"Builtin_literal-not-identical-conclusion.ntriples")
		);

static void add_import_function(crifi_graph *graph){
	if(!w3ctestcases_add_importlocations(graph)){
		close_graph(graph);
		FAIL() << "Failed to add import locations";
	}
}

static void load_from_memory_to_graph(crifi_graph *graph, const char *source_uri){
	bool errorstate;
	struct DynamicValue retval;
	char command[300]; //300 seems like a reaonable guess
	sprintf(command, "(<%s> <%s> <%s>)", _CRIFI_import_, source_uri, _RIFENTAIL_SIMPLE_);
	retval = eval(graph, command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			ASSERT_EQ(retval.val.boolean, true)
				<< "Crifi:import failed. Used:\n"
				<< command;
			break;
		default:
			FAIL() << "crifi:import return unexpected value.";
	}
	if (errorstate){
		FAIL() << "graph ended up in errorstate after import\n";
	}
}

TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelA) {
	TestdataPET testdata = GetParam();
	crifi_graph *create_logic_graph = init_graph_modelA();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt craete modelA graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	load_from_memory_to_graph(create_logic_graph, testdata.premise_uri.c_str());
	FAIL() << "brubru";
}


INSTANTIATE_TEST_SUITE_P(
		officialw3cTestcases_second,
		officialw3cPETTestCases_Test,
		petTestdata);
