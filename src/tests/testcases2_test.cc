/** \anchor testcases2_test.cc
 * testcases like those from w3c rif testcases
 */

#include <stdint.h>  /* SIZE_MAX */
#include <gtest/gtest.h>

#include "ffi_constants.h"
#include "crifi_graph_models.h"
#include "crifi_raptor.h"

///autogenerated by cmake compile_resources
#include "testdata_w3c_as_header.h"

#define _W3C_TESTDATA_ "http://www.w3.org/2005/rules/test/repository/tc/"
#define W3C_PREMISE(id) _W3C_TESTDATA_ id "/" id "-premise"
#define W3C_CONCLUSION(id) _W3C_TESTDATA_ id "/" id "-conclusion"
#define W3C_NONCONCLUSION(id) _W3C_TESTDATA_ id "/" id "-nonconclusion"

typedef crifi_graph *GraphGenerator();

typedef enum {
	SC_NoCondition = 0,
	SC_All = 1<<1,
	SC_ModelA = 1<<2,
	SC_ModelFirst = 1<<3,
} SkipCondition;

class TestdataPET {
	public:
		unsigned long skip_c;
		std::string premise_uri;
		std::string conclusion_uri;
		std::string name;
		bool result;
		TestdataPET(
				std::string Name,
				unsigned long skip_condition,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri
				){
			skip_c = skip_condition;
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
			result = true;
		}
		TestdataPET(
				std::string Name,
				unsigned long skip_condition,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri,
				bool myresult
				){
			skip_c = skip_condition;
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
			result = myresult;
		}

};

std::ostream& operator<<(std::ostream& os, const TestdataPET& td){
	os << td.name;
	return os;
}

class officialw3cPETTestCases_Test : public testing::TestWithParam<TestdataPET> {
	protected:
		/**
		 * Skip when reason is not NULL.
		 */
		void SetUp() override {
			TestdataPET q = GetParam();
			if (q.skip_c & SC_All){
				GTEST_SKIP() << "always skip";
			}
		}
};

static auto petTestdata = testing::Values(
		TestdataPET("Core_PET_Builtin_literal-not-identical",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtin_literal-not-identical/",
			"Builtin_literal-not-identical-premise",
			"Builtin_literal-not-identical-conclusion"),
		TestdataPET("Core_PET_Builtins_Binary",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_Binary/",
			"Builtins_Binary-premise",
			"Builtins_Binary-conclusion"),
		TestdataPET("Core_PET_Builtins_List",
			SC_All,
			_W3C_TESTDATA_"Builtins_List/",
			"Builtins_List-premise",
			"Builtins_List-conclusion"),
		TestdataPET("Core_PET_Builtins_Numeric",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_Numeric/",
			"Builtins_Numeric-premise",
			"Builtins_Numeric-conclusion"),
		TestdataPET("Core_PET_Builtins_PlainLiteral",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_PlainLiteral/",
			"Builtins_PlainLiteral-premise",
			"Builtins_PlainLiteral-conclusion"),
		TestdataPET("Core_PET_Builtins_String",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_String/",
			"Builtins_String-premise",
			"Builtins_String-conclusion"),
		TestdataPET("Core_PET_Builtins_Time",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_Time/",
			"Builtins_Time-premise",
			"Builtins_Time-conclusion"),
		TestdataPET("Core_PET_Builtins_XMLLiteral",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_XMLLiteral/",
			"Builtins_XMLLiteral-premise",
			"Builtins_XMLLiteral-conclusion"),
		TestdataPET("Core_PET_Builtins_anyURI",
			SC_NoCondition,
			_W3C_TESTDATA_"Builtins_anyURI/",
			"Builtins_anyURI-premise",
			"Builtins_anyURI-conclusion"),
		TestdataPET("Core_PET_Builtins_boolean",
			SC_All,
			_W3C_TESTDATA_"Builtins_boolean/",
			"Builtins_boolean-premise",
			"Builtins_boolean-conclusion"),
		TestdataPET("Core_PET_Chaining_strategy_numeric-add_1",
			SC_ModelA,
			_W3C_TESTDATA_"Chaining_strategy_numeric-add_1/",
			"Chaining_strategy_numeric-add_1-premise",
			"Chaining_strategy_numeric-add_1-conclusion"),
		TestdataPET("Core_PET_Chaining_strategy_numeric-subtract_2",
			SC_ModelA,
			_W3C_TESTDATA_"Chaining_strategy_numeric-subtract_2/",
			"Chaining_strategy_numeric-subtract_2-premise",
			"Chaining_strategy_numeric-subtract_2-conclusion"),
		TestdataPET("Core_PET_EBusiness_Contract",
			SC_All,
			_W3C_TESTDATA_"EBusiness_Contract/",
			"EBusiness_Contract-premise",
			"EBusiness_Contract-conclusion"),
		TestdataPET("Core_PET_Factorial_Forward_Chaining",
			SC_All,
			_W3C_TESTDATA_"Factorial_Forward_Chaining/",
			"Factorial_Forward_Chaining-premise",
			"Factorial_Forward_Chaining-conclusion"),
		TestdataPET("Core_PET_Frame_slots_are_independent",
			SC_ModelA,
			_W3C_TESTDATA_"Frame_slots_are_independent/",
			"Frame_slots_are_independent-premise",
			"Frame_slots_are_independent-conclusion"),
		TestdataPET("Core_PET_Frames",
			SC_ModelA,
			_W3C_TESTDATA_"Frames/",
			"Frames-premise",
			"Frames-conclusion"),
		/*
		TestdataPET("Core_PET_Guards_and_subtypes",
			SC_All,
			_W3C_TESTDATA_"Guards_and_subtypes/",
			"Guards_and_subtypes-premise",
			"Guards_and_subtypes-conclusion"),
		TestdataPET("Core_PET_Modeling_Brain_Anatomy",
			SC_All,
			_W3C_TESTDATA_"Modeling_Brain_Anatomy/",
			"Modeling_Brain_Anatomy-premise",
			"Modeling_Brain_Anatomy-conclusion"),
		TestdataPET("Core_PET_OWL_Combination_Vocabulary_Separation_Inconsistency_1",
			SC_All,
			_W3C_TESTDATA_"OWL_Combination_Vocabulary_Separation_Inconsistency_1/",
			"OWL_Combination_Vocabulary_Separation_Inconsistency_1-premise",
			"OWL_Combination_Vocabulary_Separation_Inconsistency_1-conclusion"),
		TestdataPET("Core_PET_OWL_Combination_Vocabulary_Separation_Inconsistency_2",
			SC_All,
			_W3C_TESTDATA_"OWL_Combination_Vocabulary_Separation_Inconsistency_2/",
			"OWL_Combination_Vocabulary_Separation_Inconsistency_2-premise",
			"OWL_Combination_Vocabulary_Separation_Inconsistency_2-conclusion"),
		TestdataPET("Core_PET_Positional_Arguments",
			SC_All,
			_W3C_TESTDATA_"Positional_Arguments/",
			"Positional_Arguments-premise",
			"Positional_Arguments-conclusion"),
			*/
		TestdataPET("Core_PET_RDF_Combination_Blank_Node",
			SC_ModelA,
			_W3C_TESTDATA_"RDF_Combination_Blank_Node/",
			"RDF_Combination_Blank_Node-premise",
			"RDF_Combination_Blank_Node-conclusion"),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_1",
			SC_ModelA,
			_W3C_TESTDATA_"RDF_Combination_Constant_Equivalence_1/",
			"RDF_Combination_Constant_Equivalence_1-premise",
			"RDF_Combination_Constant_Equivalence_1-conclusion"),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_2",
			SC_ModelA,
			_W3C_TESTDATA_"RDF_Combination_Constant_Equivalence_2/",
			"RDF_Combination_Constant_Equivalence_2-premise",
			"RDF_Combination_Constant_Equivalence_2-conclusion"),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_3",
			SC_All,
			_W3C_TESTDATA_"RDF_Combination_Constant_Equivalence_3/",
			"RDF_Combination_Constant_Equivalence_3-premise",
			"RDF_Combination_Constant_Equivalence_3-conclusion"),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_4",
			SC_ModelA,
			"",
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_4"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_4")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_Graph_Entailment",
			SC_All,
			"",
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_Graph_Entailment"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_Graph_Entailment")),
		/*
		TestdataPET("Core_PET_RDF_Combination_SubClass_2",
			SC_All,
			"",
			W3C_PREMISE("RDF_Combination_SubClass_2"),
			W3C_CONCLUSION("RDF_Combination_SubClass_2")),
		TestdataPET("BLD_PET_Chaining_strategy_numeric-add_2",
			SC_All,
			_W3C_TESTDATA_"Chaining_strategy_numeric-add_2/",
			"Chaining_strategy_numeric-add_2-premise",
			"Chaining_strategy_numeric-add_2-conclusion"),
		TestdataPET("BLD_PET_Chaining_strategy_numeric-subtract_1",
			SC_All,
			_W3C_TESTDATA_"Chaining_strategy_numeric-subtract_1/",
			"Chaining_strategy_numeric-subtract_1-premise",
			"Chaining_strategy_numeric-subtract_1-conclusion"),
		TestdataPET("BLD_PET_Class_Membership",
			SC_All,
			_W3C_TESTDATA_"Class_Membership/",
			"Class_Membership-premise",
			"Class_Membership-conclusion"),
		TestdataPET("BLD_PET_Classification-inheritance",
			SC_All,
			_W3C_TESTDATA_"Classification-inheritance/",
			"Classification-inheritance-premise",
			"Classification-inheritance-conclusion"),
		TestdataPET("BLD_PET_ElementEqualityFromListEquality",
			SC_All,
			_W3C_TESTDATA_"ElementEqualityFromListEquality/",
			"ElementEqualityFromListEquality-premise",
			"ElementEqualityFromListEquality-conclusion"),
		TestdataPET("BLD_PET_EntailEverything",
			SC_All,
			_W3C_TESTDATA_"EntailEverything/",
			"EntailEverything-premise",
			"EntailEverything-conclusion"),
		TestdataPET("BLD_PET_Equality_in_conclusion_1",
			SC_All,
			_W3C_TESTDATA_"Equality_in_conclusion_1/",
			"Equality_in_conclusion_1-premise",
			"Equality_in_conclusion_1-conclusion"),
		TestdataPET("BLD_PET_Equality_in_conclusion_2",
			SC_All,
			_W3C_TESTDATA_"Equality_in_conclusion_2/",
			"Equality_in_conclusion_2-premise",
			"Equality_in_conclusion_2-conclusion"),
		TestdataPET("BLD_PET_Equality_in_conclusion_3",
			SC_All,
			_W3C_TESTDATA_"Equality_in_conclusion_3/",
			"Equality_in_conclusion_3-premise",
			"Equality_in_conclusion_3-conclusion"),
		TestdataPET("BLD_PET_Equality_in_condition",
			SC_All,
			_W3C_TESTDATA_"Equality_in_condition/",
			"Equality_in_condition-premise",
			"Equality_in_condition-conclusion"),
		TestdataPET("BLD_PET_Factorial_Functional",
			SC_All,
			_W3C_TESTDATA_"Factorial_Functional/",
			"Factorial_Functional-premise",
			"Factorial_Functional-conclusion"),
		TestdataPET("BLD_PET_Factorial_Relational",
			SC_All,
			_W3C_TESTDATA_"Factorial_Relational/",
			"Factorial_Relational-premise",
			"Factorial_Relational-conclusion"),
		TestdataPET("BLD_PET_IRI_from_IRI",
			SC_All,
			"",
			W3C_PREMISE("IRI_from_IRI"),
			W3C_CONCLUSION("IRI_from_IRI")),
		TestdataPET("BLD_PET_Inconsistent_Entailment",
			SC_All,
			"",
			W3C_PREMISE("Inconsistent_Entailment"),
			W3C_CONCLUSION("Inconsistent_Entailment")),
		TestdataPET("BLD_PET_Individual-Data_Separation_Inconsistency",
			SC_All,
			"",
			W3C_PREMISE("Individual-Data_Separation_Inconsistency"),
			W3C_CONCLUSION("Individual-Data_Separation_Inconsistency")),
		TestdataPET("BLD_PET_ListConstantEquality",
			SC_All,
			"",
			W3C_PREMISE("ListConstantEquality"),
			W3C_CONCLUSION("ListConstantEquality")),
		TestdataPET("BLD_PET_ListEqualityFromElementEquality",
			SC_All,
			"",
			W3C_PREMISE("ListEqualityFromElementEquality"),
			W3C_CONCLUSION("ListEqualityFromElementEquality")),
		TestdataPET("BLD_PET_ListLiteralEquality",
			SC_All,
			"",
			W3C_PREMISE("ListLiteralEquality"),
			W3C_CONCLUSION("ListLiteralEquality")),
		TestdataPET("BLD_PET_Arbitrary_Entailment",
			SC_All,
			"",
			W3C_PREMISE("Arbitrary_Entailment"),
			W3C_CONCLUSION("Arbitrary_Entailment")),
		TestdataPET("BLD_PET_Multiple_IRIs_from_String",
			SC_All,
			"",
			W3C_PREMISE("Multiple_IRIs_from_String"),
			W3C_CONCLUSION("Multiple_IRIs_from_String")),
		TestdataPET("BLD_PET_Multiple_Strings_from_IRI",
			SC_All,
			"",
			W3C_PREMISE("Multiple_Strings_from_IRI"),
			W3C_CONCLUSION("Multiple_Strings_from_IRI")),
		TestdataPET("BLD_PET_Named_Arguments",
			SC_All,
			"",
			W3C_PREMISE("Named_Arguments"),
			W3C_CONCLUSION("Named_Arguments")),
		TestdataPET("BLD_PET_RDF_Combination_Member_1",
			SC_All,
			"",
			W3C_PREMISE("RDF_Combination_Member_1"),
			W3C_CONCLUSION("RDF_Combination_Member_1")),
		TestdataPET("BLD_PET_RDF_Combination_SubClass_4",
			SC_All,
			"",
			W3C_PREMISE("RDF_Combination_SubClass_4"),
			W3C_CONCLUSION("RDF_Combination_SubClass_4")),
		TestdataPET("BLD_PET_RDF_Combination_SubClass_6",
			SC_All,
			"",
			W3C_PREMISE("RDF_Combination_SubClass_6"),
			W3C_CONCLUSION("RDF_Combination_SubClass_6")),
		TestdataPET("BLD_PET_YoungParentDiscount_1",
			SC_All,
			"",
			W3C_PREMISE("YoungParentDiscount_1"),
			W3C_CONCLUSION("YoungParentDiscount_1")),
		*/
		TestdataPET("PRD_PET_Assert_", //_ makes unique
			SC_NoCondition,
			_W3C_TESTDATA_"Assert/",
			"Assert-premise",
			"Assert-conclusion"),
		TestdataPET("PRD_PET_AssertRetract1",
			SC_NoCondition,
			_W3C_TESTDATA_"AssertRetract/",
			"AssertRetract-premise",
			"AssertRetract-conclusion"),
		TestdataPET("PRD_PET_AssertRetract2",
			SC_ModelA,
			_W3C_TESTDATA_"AssertRetract2/",
			"AssertRetract2-premise",
			"AssertRetract2-conclusion"),
		TestdataPET("PRD_PET_Modify1",
			SC_ModelA,
			_W3C_TESTDATA_"Modify/",
			"Modify-premise",
			"Modify-conclusion"),
		TestdataPET("PRD_PET_Modify_loop",
			SC_ModelA,
			_W3C_TESTDATA_"Modify_loop/",
			"Modify_loop-premise",
			"Modify_loop-conclusion"),
		TestdataPET("Core_NET_NestedListsAreNotFlatLists",
				SC_All,
				"",
				W3C_PREMISE("NestedListsAreNotFlatLists"),
				W3C_NONCONCLUSION("NestedListsAreNotFlatLists"),
				false)
		);

static void add_import_function(crifi_graph *graph){
	if(!w3ctestcases_add_importlocations(graph)){
		close_graph(graph);
		FAIL() << "Failed to add import locations";
	}
}

static void load_from_memory_to_graph(crifi_graph *graph, const char *source_uri){
	bool errorstate;
	struct DynamicValue retval;
	char command[300]; //300 seems like a reaonable guess
	sprintf(command, "(<%s> <%s> <%s>)", _CRIFI_import_, source_uri, _RIFENTAIL_RIF_);
	retval = eval(graph, command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			ASSERT_EQ(retval.val.boolean, true)
				<< "Crifi:import failed. Used:\n"
				<< command;
			break;
		default:
			FAIL() << "crifi:import return unexpected value.";
	}
	if (errorstate){
		FAIL() << "graph ended up in errorstate after import\n";
	}
}
static void load_new_logic(crifi_graph *graph,const char* config, size_t configlength){
	RET_LOADCONFIG err = load_config_mem(graph, config, configlength);
	switch (err){
		default:
			break;
	}
}
static void create_new_check(crifi_graph *create_check_graph, FILE *memory){
	const char *errmsg;
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_function(memory, create_check_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			return;
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
			FAIL() << "Graph not usable for "
				"serialize_information_as_clips_function. "
				"Either graph structure isnt as expected or "
				"root function couldnt be found.";
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			FAIL() << "Unhandled error during serialization of "
				"graphinformation as clips script.";
	}
}

static void create_new_logic(crifi_graph *create_logic_graph, FILE *memory){
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_script(memory, create_logic_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			break;
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			FAIL() << "Unhandled error during serialization of "
				"graphinformation as clips script.";
	}
}

static void run_and_check(crifi_graph *graph, const char* check_command, bool expect){
	bool errorstate;
	struct DynamicValue retval;
	int number_rules_run = run_rules(graph, 20);
	fprintf(stderr, "numer of rules during logic: %d\n", number_rules_run);
	if (graph_in_errorstate(graph, stderr)){
		FAIL() << "graph ended up in errorstate, while running logic.";
		return;
	}

	retval = eval(graph, check_command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			EXPECT_EQ(retval.val.boolean, expect)
				<< "check command didnt returned expected "
				"value. check command was:\n"
				<< check_command;
			break;
		default:
			FAIL() << "check command return unexpected value type. "
				"check command that was used:\n"
				<< check_command;
	}
	///dont know why this doesnt work
	//if (HasNonfatalFailure()) {
		fprintf(stdout, "run and check failed? Facts after:\n");
		eval(graph, "(facts)");
	//}

	if (errorstate){
		FAIL() << "graph ended up in errorstate after check command:\n"
			<< check_command;
	}
}

static void create_logic_into_memory(FILE* tmpmem_f, TestdataPET testdata, GraphGenerator *graph_generator){
	int number_rules_run;
	crifi_graph *create_logic_graph = graph_generator();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt craete modelA graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n", testdata.premise_uri.c_str());
	load_from_memory_to_graph(create_logic_graph, testdata.premise_uri.c_str());

	number_rules_run = run_rules(create_logic_graph, 10000);
	fprintf(stderr, "information in create_logic_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during rule creation: %d\n", number_rules_run);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing new logic";
	}

	create_new_logic(create_logic_graph, tmpmem_f);
	close_graph(create_logic_graph);
	create_logic_graph = NULL;
}

static void fprintf_model_first_created_rules(FILE* out_f, crifi_graph *graph){
	bool errorstate;
	struct DynamicValue retval;
	retval = eval(graph, "(create-script-rif-logic \"mydescription\")");

	errorstate = graph_in_errorstate(graph, stderr);
	switch(retval.type){
		case CTC_DYNAMIC_STRING:
			if (0 == strcmp(retval.val.string, "")) {
				FAIL() << "not output from create-script-rif-logic";
			}
			fprintf(out_f, "%s", retval.val.string);
			break;
		case CTC_DYNAMIC_ERROR:
			FAIL() << "oops something went wrong";
		default:
			FAIL() << "oop somethign went wrong2";
	}
	if(errorstate){
		FAIL() << "graph ended in errorstate after rules have run.";
	}
}

static void create_logic_into_memory_model_first(FILE* tmpmem_f, TestdataPET testdata){
	int number_rules_run;
	crifi_graph *create_logic_graph = init_graph_model_first();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt create model first graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n", testdata.premise_uri.c_str());
	load_from_memory_to_graph(create_logic_graph, testdata.premise_uri.c_str());

	number_rules_run = run_rules(create_logic_graph, 10000);
	fprintf(stderr, "information in create_logic_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during rule creation: %d\n", number_rules_run);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing new logic";
	}

	fprintf_model_first_created_rules(tmpmem_f, create_logic_graph);
	close_graph(create_logic_graph);
	create_logic_graph = NULL;
}

static void create_check_into_memory(FILE *tmpmem_f, TestdataPET testdata, GraphGenerator *graph_generator){
	int number_rules_run;
	crifi_graph *create_check_graph;
	create_check_graph = graph_generator();
	if (create_check_graph == NULL){
		//GTEST_SKIP
		FAIL() << "couldnt create modelA check graph";
	}
	w3ctestcases_add_importlocations(create_check_graph);
	fprintf(stderr, "loading check info from: %s\n", testdata.conclusion_uri.c_str());
	load_from_memory_to_graph(create_check_graph, testdata.conclusion_uri.c_str());

	number_rules_run = run_rules(create_check_graph, 10000);
	fprintf(stderr, "information in create_check_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_check_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during check creation: %d\n", number_rules_run);
	if (graph_in_errorstate(create_check_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing check";
	}

	create_new_check(create_check_graph, tmpmem_f);
	close_graph(create_check_graph);
}


TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelA) {
	TestdataPET testdata = GetParam();
	if (testdata.skip_c & SC_ModelA){
		GTEST_SKIP() << "skip on modelA";
	}

	size_t memory_size = 1000000;
	int number_rules_run;
	char tmpmem[memory_size]; //script size maximal a megabyte
	char tmpcheckmem[memory_size]; //check command size maximal a megabyte
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	tmpcheckmem[memory_size-1] = '\0';
	tmpcheckmem[0] = '\0';
	FILE *tmpmem_f, *tmpcheckmem_f;
	crifi_graph *maingraph;

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_logic_into_memory(tmpmem_f, testdata, init_graph_modelA);
	fclose(tmpmem_f);
	if (HasFatalFailure()) return;
	if (HasFailure()) return;
	fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	ASSERT_NE(strlen(tmpmem), 0) << "no logic script created";

	tmpcheckmem_f = fmemopen(tmpcheckmem, memory_size-1, "w");
	ASSERT_NE(tmpcheckmem_f, nullptr) << "Couldnt open memory.broken test.";
	create_check_into_memory(tmpcheckmem_f, testdata, init_graph_modelcheckA);
	fclose(tmpcheckmem_f);

	if (HasFatalFailure()) return;
	fprintf(stderr, "check command:\n%s\n", tmpcheckmem);
	ASSERT_NE(strlen(tmpcheckmem), 0) << "no check command created.";


	maingraph = init_graph();
	load_new_logic(maingraph, tmpmem, strlen(tmpmem));
	run_and_check(maingraph, tmpcheckmem, testdata.result);
	close_graph(maingraph);
	//FAIL() << "testfail";
}

TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelFirst) {
	TestdataPET testdata = GetParam();
	size_t memory_size = 1000000;
	int number_rules_run;
	char tmpmem[memory_size]; //script size maximal a megabyte
	char tmpcheckmem[memory_size]; //check command size maximal a megabyte
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	tmpcheckmem[memory_size-1] = '\0';
	tmpcheckmem[0] = '\0';
	FILE *tmpmem_f, *tmpcheckmem_f;
	crifi_graph *maingraph;

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_logic_into_memory_model_first(tmpmem_f, testdata);
	fclose(tmpmem_f);
	if (HasFatalFailure()) return;
	fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	ASSERT_NE(strlen(tmpmem), 0) << "no logic script created";

	tmpcheckmem_f = fmemopen(tmpcheckmem, memory_size-1, "w");
	ASSERT_NE(tmpcheckmem_f, nullptr) << "Couldnt open memory.broken test.";
	create_check_into_memory(tmpcheckmem_f, testdata, init_graph_modelcheckA);
	fclose(tmpcheckmem_f);

	if (HasFatalFailure()) return;
	fprintf(stderr, "check command:\n%s\n", tmpcheckmem);
	ASSERT_NE(strlen(tmpcheckmem), 0) << "no check command created.";


	maingraph = init_graph();
	load_new_logic(maingraph, tmpmem, strlen(tmpmem));
	run_and_check(maingraph, tmpcheckmem, testdata.result);
	close_graph(maingraph);
	//FAIL() << "testfail";
}


INSTANTIATE_TEST_SUITE_P(
		officialw3cTestcases_second,
		officialw3cPETTestCases_Test,
		petTestdata);
