/** \anchor testcases2_test.cc
 * testcases like those from w3c rif testcases
 */

#include <stdint.h>  /* SIZE_MAX */
#include <gtest/gtest.h>

#include "ffi_constants.h"
#include "crifi_graph_models.h"
#include "crifi_raptor.h"
#include "model_support.h"

///autogenerated by cmake compile_resources
#include "testdata_w3c_as_header.h"

#define _W3C_TESTDATA_ "http://www.w3.org/2005/rules/test/repository/tc/"
#define W3C_PREMISE(id) _W3C_TESTDATA_ id "/" id "-premise"
#define W3C_CONCLUSION(id) _W3C_TESTDATA_ id "/" id "-conclusion"
#define W3C_NONCONCLUSION(id) _W3C_TESTDATA_ id "/" id "-nonconclusion"

typedef crifi_graph *GraphGenerator();

class TestdataPET {
	public:
		unsigned long skip_c;
		std::string premise_uri;
		std::string conclusion_uri;
		std::string name;
		bool result;
		TestdataPET(
				std::string Name,
				unsigned long skip_condition,
				std::string premiseUri,
				std::string conclusionUri
				){
			skip_c = skip_condition;
			premise_uri = premiseUri;
			conclusion_uri = conclusionUri;
			name = Name;
			result = true;
		}
		TestdataPET(
				std::string Name,
				unsigned long skip_condition,
				std::string premiseUri,
				std::string conclusionUri,
				bool myresult
				){
			skip_c = skip_condition;
			premise_uri = premiseUri;
			conclusion_uri = conclusionUri;
			name = Name;
			result = myresult;
		}

};

std::ostream& operator<<(std::ostream& os, const TestdataPET& td){
	os << td.name;
	return os;
}

class officialw3cPETTestCases_Test : public testing::TestWithParam<TestdataPET> {
	protected:
		/**
		 * Skip when reason is not NULL.
		 */
		void SetUp() override {
			TestdataPET q = GetParam();
			if (q.skip_c & SC_All){
				GTEST_SKIP() << "always skip";
			}
		}
};

static auto petTestdata = testing::Values(
		TestdataPET("Core_PET_Builtin_literal-not-identical",
			SC_NoCondition,
			W3C_PREMISE("Builtin_literal-not-identical"),
			W3C_CONCLUSION("Builtin_literal-not-identical")),
		TestdataPET("Core_PET_Builtins_Binary",
			SC_NoCondition,
			W3C_PREMISE("Builtins_Binary"),
			W3C_CONCLUSION("Builtins_Binary")),
		TestdataPET("Core_PET_Builtins_List",
			SC_All,
			_W3C_TESTDATA_"Builtins_List/",
			W3C_PREMISE("Builtins_List"),
			W3C_CONCLUSION("Builtins_List")),
		TestdataPET("Core_PET_Builtins_Numeric",
			SC_NoCondition,
			W3C_PREMISE("Builtins_Numeric"),
			W3C_CONCLUSION("Builtins_Numeric")),
		TestdataPET("Core_PET_Builtins_PlainLiteral",
			SC_ModelA,
			W3C_PREMISE("Builtins_PlainLiteral"),
			W3C_CONCLUSION("Builtins_PlainLiteral")),
		TestdataPET("Core_PET_Builtins_String",
			SC_NoCondition,
			W3C_PREMISE("Builtins_String"),
			W3C_CONCLUSION("Builtins_String")),
		TestdataPET("Core_PET_Builtins_Time",
			SC_NoCondition,
			W3C_PREMISE("Builtins_Time"),
			W3C_CONCLUSION("Builtins_Time")),
		TestdataPET("Core_PET_Builtins_XMLLiteral",
			SC_NoCondition,
			W3C_PREMISE("Builtins_XMLLiteral"),
			W3C_CONCLUSION("Builtins_XMLLiteral")),
		TestdataPET("Core_PET_Builtins_anyURI",
			SC_NoCondition,
			W3C_PREMISE("Builtins_anyURI"),
			W3C_CONCLUSION("Builtins_anyURI")),
		TestdataPET("Core_PET_Builtins_boolean",
			SC_All,
			W3C_PREMISE("Builtins_boolean"),
			W3C_CONCLUSION("Builtins_boolean")),
		TestdataPET("Core_PET_Chaining_strategy_numeric-add_1",
			SC_NoCondition,
			W3C_PREMISE("Chaining_strategy_numeric-add_1"),
			W3C_CONCLUSION("Chaining_strategy_numeric-add_1")),
		TestdataPET("Core_PET_Chaining_strategy_numeric-subtract_2",
			SC_NoCondition,
			W3C_PREMISE("Chaining_strategy_numeric-subtract_2"),
			W3C_CONCLUSION("Chaining_strategy_numeric-subtract_2")),
		TestdataPET("Core_PET_EBusiness_Contract",
			SC_All,
			W3C_PREMISE("EBusiness_Contract"),
			W3C_CONCLUSION("EBusiness_Contract")),
		TestdataPET("Core_PET_Factorial_Forward_Chaining",
			SC_ModelFirst,
			W3C_PREMISE("Factorial_Forward_Chaining"),
			W3C_CONCLUSION("Factorial_Forward_Chaining")),
		TestdataPET("Core_PET_Frame_slots_are_independent",
			SC_NoCondition,
			W3C_PREMISE("Frame_slots_are_independent"),
			W3C_CONCLUSION("Frame_slots_are_independent")),
		TestdataPET("Core_PET_Frames",
			SC_NoCondition,
			W3C_PREMISE("Frames"),
			W3C_CONCLUSION("Frames")),
		/*
		TestdataPET("Core_PET_Guards_and_subtypes",
			SC_All,
			W3C_PREMISE("Guards_and_subtypes"),
			W3C_CONCLUSION("Guards_and_subtypes")),
		TestdataPET("Core_PET_Modeling_Brain_Anatomy",
			SC_All,
			W3C_PREMISE("Modeling_Brain_Anatomy"),
			W3C_CONCLUSION("Modeling_Brain_Anatomy")),
		TestdataPET("Core_PET_OWL_Combination_Vocabulary_Separation_Inconsistency_1",
			SC_All,
			W3C_PREMISE("OWL_Combination_Vocabulary_Separation_Inconsistency_1"),
			W3C_CONCLUSION("OWL_Combination_Vocabulary_Separation_Inconsistency_1")),
		TestdataPET("Core_PET_OWL_Combination_Vocabulary_Separation_Inconsistency_2",
			SC_All,
			W3C_PREMISE("OWL_Combination_Vocabulary_Separation_Inconsistency_2"),
			W3C_CONCLUSION("OWL_Combination_Vocabulary_Separation_Inconsistency_2")),
		TestdataPET("Core_PET_Positional_Arguments",
			SC_All,
			W3C_PREMISE("Positional_Arguments"),
			W3C_CONCLUSION("Positional_Arguments")),
			*/
		TestdataPET("Core_PET_RDF_Combination_Blank_Node",
			SC_NoCondition,
			W3C_PREMISE("RDF_Combination_Blank_Node"),
			W3C_CONCLUSION("RDF_Combination_Blank_Node")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_1",
			SC_NoCondition,
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_1"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_1")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_2",
			SC_NoCondition,
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_2"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_2")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_3",
			SC_All,
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_3"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_3")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_4",
			SC_NoCondition,
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_4"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_4")),
		TestdataPET("Core_PET_RDF_Combination_Constant_Equivalence_Graph_Entailment",
			SC_All,
			W3C_PREMISE("RDF_Combination_Constant_Equivalence_Graph_Entailment"),
			W3C_CONCLUSION("RDF_Combination_Constant_Equivalence_Graph_Entailment")),
		/*
		TestdataPET("Core_PET_RDF_Combination_SubClass_2",
			SC_All,
			W3C_PREMISE("RDF_Combination_SubClass_2"),
			W3C_CONCLUSION("RDF_Combination_SubClass_2")),
		TestdataPET("BLD_PET_Chaining_strategy_numeric-add_2",
			SC_All,
			W3C_PREMISE("Chaining_strategy_numeric-add_2"),
			W3C_CONCLUSION("Chaining_strategy_numeric-add_2")),
		TestdataPET("BLD_PET_Chaining_strategy_numeric-subtract_1",
			SC_All,
			W3C_PREMISE("Chaining_strategy_numeric-subtract_1"),
			W3C_CONCLUSION("Chaining_strategy_numeric-subtract_1")),
		TestdataPET("BLD_PET_Class_Membership",
			SC_All,
			W3C_PREMISE("Class_Membership"),
			W3C_CONCLUSION("Class_Membership")),
		TestdataPET("BLD_PET_Classification-inheritance",
			SC_All,
			W3C_PREMISE("Classification-inheritance"),
			W3C_CONCLUSION("Classification-inheritance")),
		TestdataPET("BLD_PET_ElementEqualityFromListEquality",
			SC_All,
			W3C_PREMISE("ElementEqualityFromListEquality"),
			W3C_CONCLUSION("ElementEqualityFromListEquality")),
		TestdataPET("BLD_PET_EntailEverything",
			SC_All,
			W3C_PREMISE("EntailEverything"),
			W3C_CONCLUSION("EntailEverything")),
		TestdataPET("BLD_PET_Equality_in_conclusion_1",
			SC_All,
			W3C_PREMISE("Equality_in_conclusion_1"),
			W3C_CONCLUSION("Equality_in_conclusion_1")),
		TestdataPET("BLD_PET_Equality_in_conclusion_2",
			SC_All,
			W3C_PREMISE("Equality_in_conclusion_2"),
			W3C_CONCLUSION("Equality_in_conclusion_2")),
		TestdataPET("BLD_PET_Equality_in_conclusion_3",
			SC_All,
			W3C_PREMISE("Equality_in_conclusion_3"),
			W3C_CONCLUSION("Equality_in_conclusion_3")),
		TestdataPET("BLD_PET_Equality_in_condition",
			SC_All,
			W3C_PREMISE("Equality_in_condition"),
			W3C_CONCLUSION("Equality_in_condition")),
		TestdataPET("BLD_PET_Factorial_Functional",
			SC_All,
			W3C_PREMISE("Factorial_Functional"),
			W3C_CONCLUSION("Factorial_Functional")),
		TestdataPET("BLD_PET_Factorial_Relational",
			SC_All,
			W3C_PREMISE("Factorial_Relational"),
			W3C_CONCLUSION("Factorial_Relational")),
		TestdataPET("BLD_PET_IRI_from_IRI",
			SC_All,
			W3C_PREMISE("IRI_from_IRI"),
			W3C_CONCLUSION("IRI_from_IRI")),
		TestdataPET("BLD_PET_Inconsistent_Entailment",
			SC_All,
			W3C_PREMISE("Inconsistent_Entailment"),
			W3C_CONCLUSION("Inconsistent_Entailment")),
		TestdataPET("BLD_PET_Individual-Data_Separation_Inconsistency",
			SC_All,
			W3C_PREMISE("Individual-Data_Separation_Inconsistency"),
			W3C_CONCLUSION("Individual-Data_Separation_Inconsistency")),
		TestdataPET("BLD_PET_ListConstantEquality",
			SC_All,
			W3C_PREMISE("ListConstantEquality"),
			W3C_CONCLUSION("ListConstantEquality")),
		TestdataPET("BLD_PET_ListEqualityFromElementEquality",
			SC_All,
			W3C_PREMISE("ListEqualityFromElementEquality"),
			W3C_CONCLUSION("ListEqualityFromElementEquality")),
		TestdataPET("BLD_PET_ListLiteralEquality",
			SC_All,
			W3C_PREMISE("ListLiteralEquality"),
			W3C_CONCLUSION("ListLiteralEquality")),
		TestdataPET("BLD_PET_Arbitrary_Entailment",
			SC_All,
			W3C_PREMISE("Arbitrary_Entailment"),
			W3C_CONCLUSION("Arbitrary_Entailment")),
		TestdataPET("BLD_PET_Multiple_IRIs_from_String",
			SC_All,
			W3C_PREMISE("Multiple_IRIs_from_String"),
			W3C_CONCLUSION("Multiple_IRIs_from_String")),
		TestdataPET("BLD_PET_Multiple_Strings_from_IRI",
			SC_All,
			W3C_PREMISE("Multiple_Strings_from_IRI"),
			W3C_CONCLUSION("Multiple_Strings_from_IRI")),
		TestdataPET("BLD_PET_Named_Arguments",
			SC_All,
			W3C_PREMISE("Named_Arguments"),
			W3C_CONCLUSION("Named_Arguments")),
		TestdataPET("BLD_PET_RDF_Combination_Member_1",
			SC_All,
			W3C_PREMISE("RDF_Combination_Member_1"),
			W3C_CONCLUSION("RDF_Combination_Member_1")),
		TestdataPET("BLD_PET_RDF_Combination_SubClass_4",
			SC_All,
			W3C_PREMISE("RDF_Combination_SubClass_4"),
			W3C_CONCLUSION("RDF_Combination_SubClass_4")),
		TestdataPET("BLD_PET_RDF_Combination_SubClass_6",
			SC_All,
			W3C_PREMISE("RDF_Combination_SubClass_6"),
			W3C_CONCLUSION("RDF_Combination_SubClass_6")),
		TestdataPET("BLD_PET_YoungParentDiscount_1",
			SC_All,
			W3C_PREMISE("YoungParentDiscount_1"),
			W3C_CONCLUSION("YoungParentDiscount_1")),
		*/
		TestdataPET("PRD_PET_Assert_", //_ makes unique
			SC_NoCondition,
			W3C_PREMISE("Assert"),
			W3C_CONCLUSION("Assert")),
		TestdataPET("PRD_PET_AssertRetract1",
			SC_NoCondition,
			W3C_PREMISE("AssertRetract"),
			W3C_CONCLUSION("AssertRetract")),
		TestdataPET("PRD_PET_AssertRetract2",
			SC_NoCondition,
			W3C_PREMISE("AssertRetract2"),
			W3C_CONCLUSION("AssertRetract2")),
		TestdataPET("PRD_PET_Modify1",
			SC_NoCondition,
			W3C_PREMISE("Modify"),
			W3C_CONCLUSION("Modify")),
		TestdataPET("PRD_PET_Modify_loop",
				SC_NoCondition,
				W3C_PREMISE("Modify_loop"),
				W3C_CONCLUSION("Modify_loop")),
		TestdataPET("Core_NET_NestedListsAreNotFlatLists",
				SC_All,
				W3C_PREMISE("NestedListsAreNotFlatLists"),
				W3C_NONCONCLUSION("NestedListsAreNotFlatLists"),
				false)
		);

static void add_import_function(crifi_graph *graph){
	if(!w3ctestcases_add_importlocations(graph)){
		close_graph(graph);
		FAIL() << "Failed to add import locations";
	}
}

static void load_from_memory_to_graph(crifi_graph *graph,
					const char *source_uri)
{
	bool errorstate;
	struct DynamicValue retval;
	char command[30 + strlen(_CRIFI_import_)
			+ strlen(source_uri) + strlen(_RIFENTAIL_RIF_)];
	sprintf(command, "(<%s> <%s> <%s>)",
			_CRIFI_import_, source_uri, _RIFENTAIL_RIF_);
	retval = eval(graph, command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			ASSERT_EQ(retval.val.boolean, true)
				<< "Crifi:import failed. Used:\n"
				<< command;
			break;
		default:
			FAIL() << "crifi:import return unexpected value.";
	}
	if (errorstate){
		FAIL() << "graph ended up in errorstate after import\n";
	}
}


static void load_new_logic(crifi_graph *graph,
				const char* config, size_t configlength)
{
	RET_LOADCONFIG err = load_config_mem(graph, config, configlength);
	switch (err){
		default:
			break;
	}
}

static void create_new_check(crifi_graph *create_check_graph, FILE *memory){
	const char *errmsg;
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_function(memory,
							create_check_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			return;
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
			FAIL() << "Graph not usable for "
				"serialize_information_as_clips_function. "
				"Either graph structure isnt as expected or "
				"root function couldnt be found.";
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			FAIL() << "Unhandled error during serialization of "
				"graphinformation as clips script.";
	}
}

static void create_new_logic(crifi_graph *create_logic_graph, FILE *memory){
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_script(memory, create_logic_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			break;
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			FAIL() << "Unhandled error during serialization of "
				"graphinformation as clips script.";
	}
}

static void run_and_check(crifi_graph *graph, const char* check_command,
				bool expect){
	bool errorstate;
	struct DynamicValue retval;
	int number_rules_run = run_rules(graph, 20);
	fprintf(stderr, "number of rules during logic: %d\n", number_rules_run);
	if (graph_in_errorstate(graph, stderr)){
		FAIL() << "graph ended up in errorstate, while running logic.";
		return;
	}

	retval = eval(graph, check_command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			EXPECT_EQ(retval.val.boolean, expect)
				<< "check command didnt returned expected "
				"value. check command was:\n"
				<< check_command;
			break;
		default:
			FAIL() << "check command return unexpected value type. "
				"check command that was used:\n"
				<< check_command;
	}
	///dont know why this doesnt work
	//if (HasNonfatalFailure()) {
		fprintf(stdout, "run and check failed? Facts after:\n");
		eval(graph, "(facts)");
	//}

	if (errorstate){
		FAIL() << "graph ended up in errorstate after check command:\n"
			<< check_command;
	}
}

static void create_logic_into_memory(FILE* tmpmem_f, TestdataPET testdata,
					GraphGenerator *graph_generator)
{
	int number_rules_run;
	crifi_graph *create_logic_graph = graph_generator();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt craete modelA graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n",
					testdata.premise_uri.c_str());
	load_from_memory_to_graph(create_logic_graph,
					testdata.premise_uri.c_str());

	number_rules_run = run_rules(create_logic_graph, 10000);
	fprintf(stderr, "information in create_logic_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during rule creation: %d\n",
					number_rules_run);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing new logic";
	}

	create_new_logic(create_logic_graph, tmpmem_f);
	close_graph(create_logic_graph);
	create_logic_graph = NULL;
}

static void fprintf_model_first_created_rules(FILE* out_f, crifi_graph *graph){
	bool errorstate;
	struct DynamicValue retval;
	retval = eval(graph, "(create-script-rif-logic \"mydescription\")");

	errorstate = graph_in_errorstate(graph, stderr);
	switch(retval.type){
		case CTC_DYNAMIC_STRING:
			if (0 == strcmp(retval.val.string, "")) {
				FAIL() << "not output from "
					"create-script-rif-logic";
			}
			fprintf(out_f, "%s", retval.val.string);
			break;
		case CTC_DYNAMIC_ERROR:
			FAIL() << "oops something went wrong";
		default:
			FAIL() << "oop somethign went wrong2";
	}
	if(errorstate){
		FAIL() << "graph ended in errorstate after rules have run.";
	}
}

static void create_logic_into_memory_model_first(
		FILE* tmpmem_f, TestdataPET testdata)
{
	int number_rules_run;
	crifi_graph *create_logic_graph = init_graph_model_first();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt create model first graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n",
				testdata.premise_uri.c_str());
	load_from_memory_to_graph(create_logic_graph,
				testdata.premise_uri.c_str());

	number_rules_run = run_rules(create_logic_graph, 10000);
	fprintf(stderr, "information in create_logic_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	fprintf(stderr, "rules run during rule creation: %d\n",
				number_rules_run);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing new logic";
	}

	fprintf_model_first_created_rules(tmpmem_f, create_logic_graph);
	close_graph(create_logic_graph);
	create_logic_graph = NULL;
}

static void create_check_into_memory(FILE *tmpmem_f, TestdataPET testdata,
					GraphGenerator *graph_generator)
{
	int number_rules_run;
	crifi_graph *create_check_graph;
	create_check_graph = graph_generator();
	if (create_check_graph == NULL){
		//GTEST_SKIP
		FAIL() << "couldnt create modelA check graph";
	}
	w3ctestcases_add_importlocations(create_check_graph);
	fprintf(stderr, "loading check info from: %s\n",
					testdata.conclusion_uri.c_str());
	load_from_memory_to_graph(create_check_graph,
					testdata.conclusion_uri.c_str());

	number_rules_run = run_rules(create_check_graph, 10000);
	fprintf(stderr, "information in create_check_graph after rules run.\n");
	//ignore error:
	crifi_serialize_all_triples(create_check_graph, stderr, "turtle", "");
	//eval(create_check_graph, "(facts)");

	fprintf(stderr, "rules run during check creation: %d\n",
						number_rules_run);
	if (graph_in_errorstate(create_check_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing check";
	}

	create_new_check(create_check_graph, tmpmem_f);
	close_graph(create_check_graph);
}


TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelA) {
	TestdataPET testdata = GetParam();

	if(skip_modelA(testdata.skip_c)){
		GTEST_SKIP() << "skip on modelA";
	}

	size_t memory_size = 1000000;
	int number_rules_run;
	char tmpmem[memory_size]; //script size maximal a megabyte
	char tmpcheckmem[memory_size]; //check command size maximal a megabyte
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	tmpcheckmem[memory_size-1] = '\0';
	tmpcheckmem[0] = '\0';
	FILE *tmpmem_f, *tmpcheckmem_f;
	crifi_graph *maingraph;

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_logic_into_memory(tmpmem_f, testdata, init_graph_modelA);
	fclose(tmpmem_f);
	if (HasFatalFailure()) return;
	if (HasFailure()) return;
	fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	ASSERT_NE(strlen(tmpmem), 0) << "no logic script created";

	tmpcheckmem_f = fmemopen(tmpcheckmem, memory_size-1, "w");
	ASSERT_NE(tmpcheckmem_f, nullptr) << "Couldnt open memory.broken test.";
	create_check_into_memory(tmpcheckmem_f, testdata,
				init_graph_modelcheckA);
	fclose(tmpcheckmem_f);

	if (HasFatalFailure()) return;
	fprintf(stderr, "check command:\n%s\n", tmpcheckmem);
	ASSERT_NE(strlen(tmpcheckmem), 0) << "no check command created.";


	maingraph = init_graph();
	load_new_logic(maingraph, tmpmem, strlen(tmpmem));
	run_and_check(maingraph, tmpcheckmem, testdata.result);
	close_graph(maingraph);
	//FAIL() << "testfail";
}

TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelFirst) {
	TestdataPET testdata = GetParam();
	size_t memory_size = 1000000;
	int number_rules_run;
	char tmpmem[memory_size]; //script size maximal a megabyte
	char tmpcheckmem[memory_size]; //check command size maximal a megabyte
	if(skip_model_first(testdata.skip_c)){
		GTEST_SKIP() << "skip on modelFirst";
	}
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	tmpcheckmem[memory_size-1] = '\0';
	tmpcheckmem[0] = '\0';
	FILE *tmpmem_f, *tmpcheckmem_f;
	crifi_graph *maingraph;

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_logic_into_memory_model_first(tmpmem_f, testdata);
	fclose(tmpmem_f);
	if (HasFatalFailure()) return;
	fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	ASSERT_NE(strlen(tmpmem), 0) << "no logic script created";

	tmpcheckmem_f = fmemopen(tmpcheckmem, memory_size-1, "w");
	ASSERT_NE(tmpcheckmem_f, nullptr) << "Couldnt open memory.broken test.";
	create_check_into_memory(tmpcheckmem_f, testdata,
				init_graph_modelcheckA);
	fclose(tmpcheckmem_f);

	if (HasFatalFailure()) return;
	fprintf(stderr, "check command:\n%s\n", tmpcheckmem);
	ASSERT_NE(strlen(tmpcheckmem), 0) << "no check command created.";


	maingraph = init_graph();
	load_new_logic(maingraph, tmpmem, strlen(tmpmem));
	run_and_check(maingraph, tmpcheckmem, testdata.result);
	close_graph(maingraph);
	//FAIL() << "testfail";
}


INSTANTIATE_TEST_SUITE_P(
		officialw3cTestcases_second,
		officialw3cPETTestCases_Test,
		petTestdata);
