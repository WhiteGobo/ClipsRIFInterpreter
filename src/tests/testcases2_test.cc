/** \anchor testcases2_test.cc
 * testcases like those from w3c rif testcases
 */

#include <stdint.h>  /* SIZE_MAX */
#include <gtest/gtest.h>

#include "ffi_constants.h"
#include "crifi_graph_models.h"
#include "crifi_raptor.h"

///autogenerated by cmake compile_resources
#include "testdata_w3c_as_header.h"

#define _W3C_TESTDATA_ "http://www.w3.org/2005/rules/test/repository/tc/"

class TestdataPET {
	public:
		const char* skip;
		std::string premise_uri;
		std::string conclusion_uri;
		std::string name;
		TestdataPET(
				std::string Name,
				const char* myskip,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri
				){
			if (myskip != NULL){
				skip = myskip;
			} else {
				skip = NULL;
			}
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
		}
		TestdataPET(
				std::string Name,
				std::string prefix,
				std::string premiseUri,
				std::string conclusionUri
				){
			skip = NULL;
			premise_uri = prefix + premiseUri;
			conclusion_uri = prefix + conclusionUri;
			name = Name;
		}

};

std::ostream& operator<<(std::ostream& os, const TestdataPET& td){
	os << td.name;
	return os;
}

class officialw3cPETTestCases_Test : public testing::TestWithParam<TestdataPET> {
	protected:
		/**
		 * Skip when reason is not NULL.
		 */
		void SetUp() override {
			TestdataPET q = GetParam();
			if (q.skip != NULL) {
				GTEST_SKIP() << q.skip;
			}
		}
};



static auto petTestdata = testing::Values(
		TestdataPET("Core_PET_Builtin_literal-not-identical",
			NULL,
			_W3C_TESTDATA_"Builtin_literal-not-identical/",
			"Builtin_literal-not-identical-premise.ntriples",
			"Builtin_literal-not-identical-conclusion.ntriples")
		);

static void add_import_function(crifi_graph *graph){
	if(!w3ctestcases_add_importlocations(graph)){
		close_graph(graph);
		FAIL() << "Failed to add import locations";
	}
}

static void load_from_memory_to_graph(crifi_graph *graph, const char *source_uri){
	bool errorstate;
	struct DynamicValue retval;
	char command[300]; //300 seems like a reaonable guess
	sprintf(command, "(<%s> <%s> <%s>)", _CRIFI_import_, source_uri, _RIFENTAIL_SIMPLE_);
	retval = eval(graph, command);
	errorstate = graph_in_errorstate(graph, stderr);
	switch (retval.type){
		case CTC_DYNAMIC_ERROR:
			switch (retval.val.error){
				case CTC_CTD_PARSING_ERROR:
					FAIL() << "parsing error? test broken? "
						"crifi:import is maybe not "
						"loaded as "
						"user defined function";
				case CTC_CTD_PROCESSING_ERROR:
					FAIL() << "failed processing command.";
				case CTC_CTD_CANTTRANSLATE:
					FAIL() << "Cant process returned "
						"CLIPSValue to DynamicType";
				default:
					FAIL() << "eval import failed. "
						"Unhandled error.";
			}
			break;
		case CTC_DYNAMIC_BOOL:
			ASSERT_EQ(retval.val.boolean, true)
				<< "Crifi:import failed. Used:\n"
				<< command;
			break;
		default:
			FAIL() << "crifi:import return unexpected value.";
	}
	if (errorstate){
		FAIL() << "graph ended up in errorstate after import\n";
	}
}

static void create_new_logic(crifi_graph *create_logic_graph, FILE *memory){
	CRIFI_SERIALIZE_SCRIPT_RET err;
	err = serialize_information_as_clips_script(memory, create_logic_graph);
	switch(err){
		case CRIFI_SERIALIZE_SCRIPT_NOERROR:
			break;
		case CRIFI_SERIALIZE_MALLOC_ERROR:
		case CRIFI_SERIALIZE_BROKEN_GRAPH:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_NODE:
		case CRIFI_SERIALIZE_SCRIPT_CANT_CREATE_STRUCTS:
		case CRIFI_SERIALIZE_SCRIPT_UNHANDLED_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_SUBJECT:
		case CRIFI_SERIALIZE_SCRIPT_PREDICATE:
		case CRIFI_SERIALIZE_SCRIPT_FAILED_ADDING_NEW_NODE:
		case CRIFI_SERIALIZE_SCRIPT_OBJECT:
		case CRIFI_SERIALIZE_SCRIPT_INPUT:
		case CRIFI_SERIALIZE_SCRIPT_UNKNOWN:
		default:
			FAIL() << "Unhandled error during serialization of "
				"graphinformation as clips script.";
	}
}

TEST_P(officialw3cPETTestCases_Test, CreateAndTestModelWithModelA) {
	TestdataPET testdata = GetParam();
	size_t memory_size = 1000000;
	char tmpmem[memory_size]; //script size maximal a megabyte
	tmpmem[memory_size-1] = '\0';
	tmpmem[0] = '\0';
	FILE *tmpmem_f;
	crifi_graph *maingraph;
	crifi_graph *create_logic_graph = init_graph_modelA();
	if (create_logic_graph == NULL){
		GTEST_SKIP() << "couldnt craete modelA graph";
	}
	w3ctestcases_add_importlocations(create_logic_graph);
	fprintf(stderr, "loading logic info from: %s\n", testdata.premise_uri.c_str());
	load_from_memory_to_graph(create_logic_graph, testdata.premise_uri.c_str());

	//ignore error:
	crifi_serialize_all_triples(create_logic_graph, stderr, "turtle", "");

	run_rules(create_logic_graph, -1);
	if (graph_in_errorstate(create_logic_graph, stderr)){
		FAIL() << "graph ended up in errorstate, while "
			"createing new logic";
	}

	tmpmem_f = fmemopen(tmpmem, memory_size-1, "w");
	ASSERT_NE(tmpmem_f, nullptr) << "Couldnt open memory. broken test.";
	create_new_logic(create_logic_graph, tmpmem_f);
	fclose(tmpmem_f);
	fprintf(stderr, "<created script>:\n%s\n</created script>\n", tmpmem);
	FAIL() << "testfailure";
}


INSTANTIATE_TEST_SUITE_P(
		officialw3cTestcases_second,
		officialw3cPETTestCases_Test,
		petTestdata);
